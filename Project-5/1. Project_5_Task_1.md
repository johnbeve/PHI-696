# Born Free But Everywhere in SHACL #

For this project, the class will divide into two teams. Teams will be divided according to the following tasks: 
```
1. Construct and validate a SHACL scheme for Basic Formal Ontology
2. Construct five useful, general, novel SHACL patterns
```
I strongly encourage you leverage your understanding of description logics for both tasks; if you understand what can be expressed in OWL, then you can more easily construct SHACL constraints on expressions in OWL. 
Protege allows one to construct and test SHACL constraints. If you explore a bit, you'll be able to identify a way to visualize the constraints in a graph as you develop them as well. 


## Task 1 ##

The team pursuing task 1 will focus on constructing and validating a SHACL scheme for Basic Formal Ontology (BFO). It is not enough, however, to simply construct a SHACL file that parallels the BFO OWL file. That can be automated, as a matter of fact. Completing this task, rather, requires the construction of a SHACL file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible. As you know, the FOL version of BFO expresses semantic content that cannot be expressed in BFO OWL version, since the latter uses a more restrictive language than the former. 

To validate your SHACL schema for BFO, you will need to generate a knowledge graph based on BFO with instance data added. You will then need to run your SHACL schema against this knowledge graph and generate a report absent errors or warnings. This must be done while respecting the semantics of the FOL version of BFO to the extent possible. 

This work will provide the foundation for a publication that illustrates how SHACL may be used to bridge the semantics of a data model whose implementations require expressivity restrictions. Completion of this task will thus make you eligible for co-authorship on the resulting publication. Students are encouraged, but not required, to continue building on this work as a final course project. 

You will need the following files: 

1. [BFO-FOL](https://github.com/BFO-ontology/BFO-2020/tree/master/21838-2/pdf)
2. [BFO-OWL](https://github.com/BFO-ontology/BFO-2020/blob/master/21838-2/owl/bfo-2020.owl)

You may find the following resources useful:

3. [SHACL W3C](https://www.w3.org/TR/shacl/)
4. [BFO 2.0 User Guide](https://ncorwiki.buffalo.edu/index.php/Basic_Formal_Ontology_2.0) - Link under "Background Information" 


## Task 2 ##

The team pursuing task 2 will focus on constructing 5-10 useful, general, novel SHACL constraints. 

By "useful", I mean a SHACL constraint that reflects a compelling use case. For example, in the DASH library one finds dash:AllObjects which represents the set of all objects in a data graph, and which is used in scenarios where a shape is expected to apply to any object, no matter the subject or predicate. This is a useful constraint for determining whether a graph contains no literals. 

By "general", I mean a SHACL constraint that is not restricted to a single ontology, upper-level or otherwise, but rather can be used by many ontologies with minimal adjustment, if any. 

By "novel" I mean a SHACL constraint does not currently exist. I encourage you to explore widely to determine whether your constraint exists; I will be. You should not, for example, duplicate any constraints from the SHACL W3C documentation or from the DASH library, though you are free to use such constraints as inspiration. 

This work will provide the foundation for a publication describing a new extension of the SHACL library designed for wide use in the ontology community. Completion of this task will thus make you eligible for co-authorship on the resulting publication. Students are encouraged, but not required, to continue building on this work as a final course project. 

You may find the following resources useful: 

1. [SHACL W3C](https://www.w3.org/TR/shacl/)
2. [DASH Library](https://datashapes.org/dash.html)


## Assignment to Teams ##

The class will be divided evenly. Students are expected to determine allotment, but teams must be comprised of the same number of members (with a +1/-1 deviation allowed). This is an exercise in project management. I encourage you to identify a strategy early for dividing sub-tasks, setting deadlines, and addressing blockers to progress.  

I suggest setting up 15 minute 'stand-up' meetings every other day, where team members are expected to join. zoom call or meet in person and (a) explain what progress they have made on their sub-task, (b) explain what they intend to achieve before the next stand-up, and (c) share any blockers that have to progress. This is an effective way to keep members focused on a team goal, as well as opportunities to overcome challenges. 

___

## Project 5, Task 1 ##

**Group 1: Karl Peihong Xie, Giacomo De Colle, Finn Wilson, Olivia Hobai, Jaron Cheung, Matthew Jones, Ali Hasanzadeh, Tim Prudhomme**

**Introduction:**

The result of our work on project 5, task 1 is a collection of SHACL shapes that enforce the following sets of BFO first order logic axioms: Continuant Mereology, Existence Instantiation, Generic Dependence, History, Material Entity, Occurrent Mereology, Order, and Spatial Axioms. 

These shapes are, as a last step, added to a file created from Astrea that includes shapes for the .owl axioms and classes of BFO. A knowledge graph was also created with instances that comply with the .owl version of BFO. Shapes from both sources have been checked against the knowledge graph by using the SHACL plugin (“SHACL4Protege”) in Protege.  

Notice that the original knowledge graph, validated against the .owl shapes will now produce errors for a large part of the FOL shapes. This is not only expected but informative, because it shows how .owl (and DL) are weaker than FOL, and these errors show in which cases the FOL axioms add something to the strength of the .owl version.

While we originally wanted to build a good knowledge graph compliant with the semantics of FOL, this appears to be a much harder work than we originally anticipated it to be, especially if we want to start from the .owl KG. For example, “Particulars exist at some time [nmq-1]” would require us to add an exists_at property for each of the 41 individuals we have in the KG. This is not a problem, but it becomes a problem considering that we need to do something similar for almost all of the 100+ axioms we have been working on. 

Speaking of other broad problems with translating FOL into SHACL, and hopefully shading some theoretical light on the difference between the two: we have found two recurring problems in our work. The first is translating n-plus relations with n>2 into SHACL. SHACL, and in general DL, seems to be in trouble dealing with non-binary relations. The second is, unsurprisingly, time. FOL-BFO refers to time by using “t”. Usually, it does so in n-place relations with n>2, e.g. “instanceOf(i,u,t)”, which makes it even worse for someone who wants to put it into SHACL. Besides that, the problem is that BFO has no “time” class. We then need to reference to temporal regions and use exists_at or some similar relation. But this is clearly not the same thing, and in turn makes the SHACL shape even more complicated and difficult to work with. 

**At a glance:**

Our team attempted to create a SHACL first order logic enforced shape of **110** axioms. 10 of these SHACL shapes returned errors and/or violations when tested and we were unable to validate them in time for compilation into our final SHACL schema.

In the end, we were able to validate a total of **96** SHACL first order logic enforced shapes returning no errors or violations.

Our Project 5 folder is comprised of the following files:

**BFO 2020 Knowledge Graph with Instance Data Added:** 
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/2.%20Project_5_BFO_2020_Knowledge%20Graph.ttl

**BFO Template SHACL Schema (Created with Astrea):**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/3.%20Project_5_Template_BFO_SHACL_Schema.ttl

**BFO FINAL SHACL Schema with 96 FOL Enforced Shapes:**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/4.%20Project_5_FINAL_BFO_SHACL_Schema.ttl

**BFO Special Collection SHACL Schema (Only Added Continuant Mereology, Existence Instantiation, and Generic Dependence):**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/4.%20Project_5_FINAL_BFO_SHACL_Schema.ttl

After creating 96 validated FOL enforced SHACL shapes, we added all of them into the **BFO FINAL SHACL Schema file**. When we ran SHACL4Protege to validate our final schema, it returned an error. 

In an attempt to try and return a result with no errors, we created a reduced SHACL schema called **BFO Special Collection SHACL Schema**. In this file we only added the continuant mereology, existence instantiation, and generic dependence SHACL shapes. When we ran SHACL4Protege to validate our final schema, the result was more promising as it returned no errors. However, though the result returned no errors, it returned with 1197 violations.

The scope of this project was enormous and we unforunately were not able to construct FOL enforced SHACL shapes for every axiom in BFO 2020. 

However, we did complete the majority of axioms from the following sections: Continuant Mereology, Existence Instantiation, Generic Dependence, History, Material Entity, Occurrent Mereology, and Order. We also completed 4 for Spatial Axioms. 

To see our cumulative (and rough draft/behind the scenes) work for this project, please go to this link: https://docs.google.com/document/d/1miP3WUXwh3rG3AoBgrDXQrfRwlesV-7XlMhrtjQG2sc/edit#heading=h.qaiiyhng5r46

Thank you for taking the time to review our project. We are grateful for this opportunity to learn and collaborate with you and each other! 

___

**Objectives for Project 5 Task 1 Completion:**

```
1. Generate a knowledge graph based on BFO with instance data added that respect the semantics of the first order logic version of BFO.
2. Construct a SHACL schema/file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible.
3. Validate the SHACL schema/file for BFO by running the SHACL file against the knowledge graph based on BFO and generate a report absent errors or warnings.
```

___


**Part 1–Objective 1 & 2:**

1. Generate a knowledge graph based on BFO with instance data added that respect the semantics of the first order logic version of BFO.

**BFO 2020 Knowledge Graph with Instance Data Added:**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/2.%20Project_5_BFO_2020_Knowledge%20Graph.ttl

2. Construct a SHACL schema/file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible.

**BFO Template SHACL Schema (Created with Astrea):**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/3.%20Project_5_Template_BFO_SHACL_Schema.ttl

```
Work Distribution:

Karl: Continuant Mereology 
Giacomo: Existence Instantiation
Finn: Generic Dependence
Olivia: History
Jaron: Material Entity
Ali:  Occurrent Mereology
Matt: Order
Tim: Spatial Axioms
```

___

**BFO 2020 Continuant Mereology Axioms (31 axioms, 6 axioms not included in the final SHACL schema): Karl Peihong Xie**

```
#Continuant part of and has continuant part are inverse relations [eld-1]
#∀t,a,b(continuantPartOf(a,b,t)↔hasContinuantPart(b,a,t))
#continuant (bfo:0000002), continuant part of at some time (bfo:0000176), has continuant part at some time (bfo:0000178)
 
ex:eld-1 a sh:NodeShape ;
    	sh:targetClass bfo:0000002 ;
    	sh:and (
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000176 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000178 ] ;
                           	   sh:minCount 1 ] ] )
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000178 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000176 ] ;
                              	sh:minCount 1 ] ] )
    	).
```

```
#Continuant part of is reflexive at a time [mcd-1]
#∀a,t(instanceOf(a,independentContinuant,t)→continuantPartOf(a,a,t))
# independent continuant (bfo:0000004), continuant part of at some time (bfo:0000176)
 
ex:mcd-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000004 ;
    sh:rule [
    	a sh:TripleRule ;
    	sh:subject :this ;
    	sh:predicate bfo:0000176 ;
    	sh:object :this ;
    	sh:condition [
        	a sh:TriplePattern ;
        	sh:subject :this ;
        	sh:predicate rdf:type ;
    	    sh:object bfo:0000004 ;
    	] ;
	] .
```

```
#Proper continuant part of and has proper continuant part are inverse relations [hpm-1]
#∀t,a,b(properContinuantPartOf(a,b,t)↔hasProperContinuantPart(b,a,t))
#continuant (bfo:0000002), proper continuant part of at some time (bfo:0000175), has proper continuant part at some time (bfo:0000174)
 
ex:hpm-1 a sh:NodeShape ;
    	sh:targetClass bfo:0000002 ;
    	sh:and (
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000174 ] ] ]
          	[ sh:property   [ sh:path [sh:inversePath bfo:0000175 ] ;
                              	sh:minCount 1 ] ] )
    	sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000175 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000174 ] ;
                              	sh:minCount 1 ] ] )
    	).
```

```
#Exists at is dissective on first argument when it is a continuant [uns-1]
#∀p,q,r(existsAt(p,q)∧continuantPartOf(r,p,q)→existsAt(r,q))
#exists_at (bfo:0000108), continuant part of at some time (bfo:0000176)
 
ex:uns-1
a sh:NodeShape ;
sh:targetSubjectsOf bfo:0000176;
	sh:or (
      	[sh:not [
      	sh:targetObjectsOf bfo:0000176;
      	sh:property [
      	sh:path bfo:0000108 
      	] ] ]
      	[sh:property [
      	sh:path bfo:0000108 ] ] ).
```

```
#A fiat point has no parts other than itself [jgo-1]
#∀fp,t,p(instanceOf(fp,fiatPoint,t)∧continuantPartOf(p,fp,t)→p=fp)
#fiat point (bfo:0000147), continuant part of at some time (bfo:0000176)
 
ex:jgo-1
	a sh:NodeShape ;
sh:targetClass bfo:0000147 ;
sh:property [
sh:path [sh:inversePath bfo:0000176] ;
sh:or (
[sh:maxCount 0]
[sh:hasValue :this; sh:maxCount 1; sh:minCount 1 ] ) ] .
```

``` 
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is dissective on third argument, a temporal region [mqp-1]
#∀p,q,r,s(continuantPartOf(p,q,r)∧temporalPartOf(s,r)→continuantPartOf(p,q,s))
# continuant part of at some time (bfo:0000176), temporal part of (bfo:0000139)
#John recommends reading a paper on Temporally Qualified Continuant Strategy (TQCS) (link: https://johnbeverley.com/blogic/2018/6/13/binary-relations-in-owl-generic-and-specific ). The basic idea of TQCS is to technically divide a continuant (John) into different temporally qualified continuants or TQCs (John-2000, John2000-2085, John-april2023 and so on). These TQCs look like temporal parts of John, but we aren't thereby ontologically committed to them. Rather, they are ad hoc computational artifacts. However, with these ad hoc artifacts, a three-placed relationship claim "x is part of y at t" can be treated as a binary-relation claim in OWL like "xt is part of y", where "xt" is a TQC of x at t.
#A possible TQCS-based translation: ∀p,q,r,s(continuantPartOf(pr,qr)∧phaseOf(r,pr)∧phaseOf(r,qr)∧temporalPartOf(s,r) → continuantPartOf(ps,qs)∧phaseOf(s,ps)∧phaseOf(s,qs))
```
 
``` 
#If a has continuant part b then if a is an instance of fiat point then b is an instance of fiat point [jqd-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatPoint,t)→instanceOf(q,fiatPoint,t))
# has continuant part at some time (bfo:0000178), fiat point (bfo:0000147)
 
ex:jqd-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000147 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000147 ] .
```

``` 	
#x is a proper continuant part of y if and only if x is a continuant part of y but y is not continuant part of x [sls-1]
#∀x,y,t(properContinuantPartOf(x,y,t)↔continuantPartOf(x,y,t)∧¬continuantPartOf(y,x,t))
#proper continuant part at some time (bfo:0000175), continuant part of at some time (bfo:0000176), continuant (bfo:0000002)
 
ex:sls-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?x bfo:0000176 ?y .
FILTER NOT EXIST {
?y bfo:0000176 ?x . }
}
WHERE {
?x bfo:0000175 ?y.
}
""" ; ] ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?x bfo:0000175 ?y .
}
WHERE {
?x bfo:0000176 ?y .
FILTER NOT EXIST {
?y bfo:0000176 ?x . }
}
""" ; ] .
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is dissective on third argument, a temporal region [vjv-1]
#∀p,q,r,s(properContinuantPartOf(p,q,r)∧temporalPartOf(s,r)→properContinuantPartOf(p,q,s))
#proper continuant part at some time (bfo:0000175), temporal part of (bfo:0000139)
#TQCS???
```

``` 
#If a continuant part of b then if a is an instance of material entity then b is an instance of material entity [dok-1]
#∀p,q,t(continuantPartOf(p,q,t)∧instanceOf(p,materialEntity,t)→instanceOf(q,materialEntity,t))
#continuant part of at some time (bfo:0000176), material entity (bfo:0000040)
 
ex:dok-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000040 ;
	sh:property [
    	sh:path bfo:0000176 ;
    	sh:class bfo:0000040 ] .
 ```

```
#If a continuant part of b then if a is an instance of spatial region then b is an instance of spatial region, and vice versa [kbr-1]
#∀p,q,t(continuantPartOf(p,q,t)→(instanceOf(p,spatialRegion,t)↔instanceOf(q,spatialRegion,t)))
#continuant part of at some time (bfo:0000176), spatial region (bfo:0000006)
 
ex:kbr-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000006 ;
	sh:property [
        sh:path bfo:0000176 ;
    	sh:class bfo:0000006 ] ;
sh:property [
    sh:path [sh:inversePath bfo:0000176 ] ;
    sh:class bfo:0000006 ]
 ```

```
#If a has continuant part b then if a is an instance of fiat surface then b is an instance of continuant fiat boundary [ysp-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatSurface,t)→instanceOf(q,continuantFiatBoundary,t))
# has continuant part at some time (bfo:0000178), fiat surface (bfo:0000146), continuant fiat boundary (bfo:0000140)
 
ex:ysp-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000146 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000140 ] .
```
 
```
#If a has continuant part b then if a is an instance of three dimensional spatial region then b is an instance of spatial region [fzg-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,threeDimensionalSpatialRegion,t)→instanceOf(q,spatialRegion,t))
# has continuant part at some time (bfo:0000178), three dimensional spatial region (bfo:0000028), spatial region (bfo:0000006)
 
ex:fzg-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000028 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000006 ] .
```

```
#If a has continuant part b then if a is an instance of continuant fiat boundary then b is an instance of continuant fiat boundary [ixo-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,continuantFiatBoundary,t)→instanceOf(q,continuantFiatBoundary,t))
#has continuant part at some time (bfo:0000178), continuant fiat boundary (bfo:0000140)
 
ex:fzg-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000140 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000140 ] .
```

``` 
#If a continuant part of b then if a is an instance of site then b is an instance of site or material entity [izr-1]
#∀p,q,t(continuantPartOf(p,q,t)∧instanceOf(p,site,t)→instanceOf(q,site,t)∨instanceOf(q,materialEntity,t))
#continuant part of at some time (bfo:0000176), site (bfo:0000029), material entity (bfo:0000040)
 
ex:izr-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000029 ;
	sh:property [
    	sh:path bfo:0000176 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000029 ]
[sh:class bfo:0000040 ] ) ] ] ] .
```
 
```
#If a continuant part of b then if a is an instance of independent continuant then b is an instance of independent continuant, and vice versa [cez-1]
#∀p,q,t(continuantPartOf(p,q,t)→(instanceOf(p,independentContinuant,t)↔instanceOf(q,independentContinuant,t)))
#continuant part of at some time (bfo:0000176), independent continuant (bfo:0000004)
 
ex:cez-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000004 ;
	sh:property [
    	sh:path bfo:0000176 ;
    	sh:class bfo:0000004 ] ;
sh:property [
    sh:path [sh:inversePath bfo:0000176 ] ;
    sh:class bfo:0000004 ]
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is transitive at a time [plp-1]
#∀a,b,c,t,t2(continuantPartOf(a,b,t)∧continuantPartOf(b,c,t2)∧temporalPartOf(t,t2)→continuantPartOf(a,c,t))
#If x is a continuant part of y at t1, and y is a continuant part of z at t2, and t1 is a temporal part of t2, then x is a continuant part of z at t1.
#continuant part of at some time (bfo:0000176), temporal part of (bfo:0000139)
#TQCS???
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is time indexed and has domain: continuant and range: continuant [bdd-1]
#∀a,b,t(continuantPartOf(a,b,t)→instanceOf(a,continuant,t)∧instanceOf(b,continuant,t)∧instanceOf(t,temporalRegion,t))
#continuant (bfo:0000002), continuant part of at some time (bfo:0000176), temporal region (bfo:0000008)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of fiat line then b is an instance of fiat line or fiat point [cwp-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatLine,t)→instanceOf(q,fiatLine,t)∨instanceOf(q,fiatPoint,t))
# has continuant part at some time (bfo:0000178), fiat line (bfo:0000142), fiat point (bfo:0000147)
 
ex:cwp-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000142 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
        	  [sh:class bfo:0000142 ]
[sh:class bfo:0000147 ] ) ] ] ] .
```

``` 
#If a has continuant part b then if a is an instance of site then b is an instance of site or continuant fiat boundary [mjj-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,site,t)→instanceOf(q,site,t)∨instanceOf(q,continuantFiatBoundary,t))
# has continuant part at some time (bfo:0000178), site (bfo:0000029), continuant fiat boundary (bfo:0000140)
 
ex:mjj-1
	a sh:NodeShape ;
    sh:targetClass bfo:0000029 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000029 ]
[sh:class bfo:0000140 ] ) ] ] ] .
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is time indexed and has domain: continuant and range: continuant [kte-1]
#∀a,b,t(properContinuantPartOf(a,b,t)→instanceOf(a,continuant,t)∧instanceOf(b,continuant,t)∧instanceOf(t,temporalRegion,t))
#continuant (bfo:0000002), proper continuant part of at some time (bfo:0000175), temporal region (bfo:0000008)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of zero dimensional spatial region then b is an instance of zero dimensional spatial region [bfv-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,zeroDimensionalSpatialRegion,t)→instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), zero dimensional spatial region (bfo:0000018)
 
ex:bfv-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000018 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000018 ] .
```

``` 
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is transitive at a time [xpg-1]
#∀a,b,c,t,t2(properContinuantPartOf(a,b,t)∧properContinuantPartOf(b,c,t2)∧temporalPartOf(t,t2)→properContinuantPartOf(a,c,t))
#proper continuant part of at some time (bfo:0000175), temporal part of (bfo:0000139)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of material entity then b is an instance of site or continuant fiat boundary or material entity [mic-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,materialEntity,t)→instanceOf(q,site,t)∨instanceOf(q,continuantFiatBoundary,t)∨instanceOf(q,materialEntity,t))
# has continuant part at some time (bfo:0000178), material entity (bfo:0000040), site (bfo:0000029), continuant fiat boundary (bfo:0000140)
 
ex:mic-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000040 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:node [
      	sh:property [
        	sh:path rdf:type ;
        	sh:node [
        	sh:or (  
          	[a bfo:0000029 ]
          	[a bfo:0000140 ]
          	[a bfo:0000040 ]
           	) ] ] ] ].
```

```
#If a has continuant part b then if a is an instance of one dimensional spatial region then b is an instance of one dimensional spatial region or zero dimensional spatial region [wne-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,oneDimensionalSpatialRegion,t)→instanceOf(q,oneDimensionalSpatialRegion,t)∨instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), one dimensional spatial region (bfo:0000026), zero dimensional spatial region (bfo:0000018)
 
ex:wne-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000026 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000026 ]
[sh:class bfo:0000018 ]
) ] ] ] .
```

```
#If at all times that two object aggreates exist each is part of the other, then they are identical [glc-1]
#∀a,b((∃t(instanceOf(a,objectAggregate,t)∧continuantPartOf(a,b,t)∧continuantPartOf(b,a,t)))∧(∀t(continuantPartOf(a,b,t)↔continuantPartOf(b,a,t)))→a=b)
#object aggregate (bfo:0000027), continuant part of at some time (bfo:0000176)
 
ex:glc-1
a sh:NodeShape ;
sh:targetClass bfo:0000027 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?a owl:sameAs ?b .
}
WHERE {
  ?a bfo:0000176 ?b .
  ?b bfo:0000176 ?a .
}
""" ; ] .
```

```
#If a material entity has a proper part, then at least one of its proper parts is not an immaterial entity [adm-1]
#∀m,t(instanceOf(m,materialEntity,t)∧(∃mp(continuantPartOf(mp,m,t)∧mp̸=m))→∃mp(mp̸=m∧continuantPartOf(mp,m,t)∧¬instanceOf(mp,immaterialEntity,t)))
#material entity (bfo:0000040), immaterial entity (bfo:0000141), has proper continuant part at some time (bfo:0000174)
 
ex:adm-1 a sh:NodeShape ;
        sh:targetClass bfo:0000040 ;
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000174 ] ; sh:minCount 1 ] ]
          	[sh:not    	[ sh:property [ sh:path bfo:0000174 ]; sh:class bfo:0000141] ]
) .
```

```
#If a has continuant part b then if a is an instance of two dimensional spatial region then b is an instance of two dimensional spatial region or one dimensional spatial region or zero dimensional spatial region [hbn-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,twoDimensionalSpatialRegion,t)→instanceOf(q,twoDimensionalSpatialRegion,t)∨instanceOf(q,oneDimensionalSpatialRegion,t)∨instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), two dimensional spatial region (bfo:0000009), one dimensional spatial region (bfo:0000026), zero dimensional spatial region (bfo:0000018)
 
ex:hbn-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000009 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000009 ]
[sh:class bfo:0000026 ]
[sh:class bfo:0000018 ]
) ] ] ] .
```

```
#If at any time that two non object aggreates exist each is part of the other, then they are identical [tab-1]
#∀a,b(∃t(instanceOf(a,independentContinuant,t)∧¬instanceOf(a,objectAggregate,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,objectAggregate,t)∧continuantPartOf(a,b,t)∧continuantPartOf(b,a,t))→a=b)
#independent continuant (bfo:0000004), object aggregate (bfo:0000027), continuant part of at some time (bfo:0000176), continuant part of at all time (bfo:0000177)
 
ex:tab-1
a sh:NodeShape ;
sh:targetClass bfo:0000004 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?a owl:sameAs ?b .
}
WHERE {
  ?a bfo:0000176 ?b .
  ?b bfo:0000176 ?a .
  FILTER NOT EXISTS {
	?a a bfo:0000027 .
?b a bfo:0000027 . }
}
""" ; ] .
```

``` 
#Continuant part of has weak supplementation [fyf-1]
#∀t,x,y(instanceOf(x,continuant,t)∧instanceOf(y,continuant,t)∧instanceOf(t,temporalRegion,t)→(continuantPartOf(x,y,t)∧x̸=y→∃z(instanceOf(z,continuant,t)∧continuantPartOf(z,y,t)∧z̸=y∧¬(∃overlap(instanceOf(overlap,continuant,t)∧continuantPartOf(overlap,x,t)∧continuantPartOf(overlap,z,t))))))
#Axiom [tab-1]: For any two continuants x and y, and any temporal region t, if x is a continuant part of y at t and x is not equal to y, then there exists a continuant z such that z is a continuant part of y at t and z is not equal to y, and x and z has no common continuant part at t.
#continuant (bfo:0000002), temporal region (bfo:0000008), continuant part of at some time (bfo:0000176)
 
ex:fyf-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:ask """
ASK WHERE {
  ?x bfo:0000176 ?y .
  ?z bfo:0000176 ?y .
  FILTER (?x != ?y && ?z != ?y)
  FILTER NOT EXISTS {
	?w bfo:0000176 ?x .
?w bfo:0000176 ?z . }
}
""" ; ] .
```

```
#Continuant part of has a unique product at a time [gzr-1]
#∀x,y,t(instanceOf(x,continuant,t)∧instanceOf(y,continuant,t)∧instanceOf(t,temporalRegion,t)→(∃overlap(instanceOf(overlap,continuant,t)∧continuantPartOf(overlap,x,t)∧continuantPartOf(overlap,y,t))→∃overlap(instanceOf(overlap,continuant,t)∧(∀w(instanceOf(w,continuant,t)→(continuantPartOf(w,overlap,t)↔continuantPartOf(w,x,t)∧continuantPartOf(w,y,t)))))))
#continuant (bfo:0000002), temporal region (bfo:0000008), continuant part of at some time (bfo:0000176)
#[gzr-1]: For any two continuants x and y, if x and y have a common continuant part, then there exists a product z such that w is a continuant part of z iff w is both a continuant part of x and a continuant part of y.
 
ex:gzr-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?w bfo:0000176 ?z .
}
WHERE {
  ?w bfo:0000176 ?x .
  ?w bfo:0000176 ?y .
}
""" ; ] ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?w bfo:0000176 ?x .
  ?w bfo:0000176 ?y .
}
WHERE {
  ?s bfo:0000176 ?x .
  ?s bfo:0000176 ?y .
  w? bfo:0000176 ?z .
}
""" ; ] .
```

___

**BFO 2020 Existence Instantiation Axioms (8 axioms, 2 axioms not included in the final SHACL schema): Giacomo De Colle**

```
#Particulars exist at some time [nmq-1]
#∀p(particular(p)→∃t existsAt(p,t))
#Bfo:entity (bfo:0000001) bfo:existsat (bfo:0000108)

ex:Particulars_exist_at_some_time_nmq-1
    a sh:NodeShape ;
    sh:targetClass obo:bfo_0000001 ;
    sh:property [       
    sh:path obo:bfo_0000108 ;     
    sh:minCount 1 ;    
    ] .
```

```
#Every universal is instantiated at least once [mbf-1]
#∀u(universal(u)→∃p,t instanceOf(p,u,t))

ex:Every_universal_is_instantiated
    a sh:NodeShape ;
    sh:targetObjectsOf rdf:type;
            sh:property [
            sh:path bfo:exists_at;
            sh:minCount 1 ;
        ]  .
```

```
#Exists at is dissective on first argument when it is a continuant [uns-1]
#∀p,q,r(existsAt(p,q)∧continuantPartOf(r,p,q)→existsAt(r,q))
# continuantpartofatsometime (BFO:0000176)
#bfo:existsat (bfo:0000108)

ex:uns-1
a sh:NodeShape ;
sh:targetSubjectsOf bfo:0000176;
    sh:or (
          [sh:not [
          sh:targetObjectsOf bfo:0000176;
          sh:property [
          sh:path bfo:0000108;
          sh:minCount 1
          ] ] ]
          [sh:property [
          sh:path bfo:0000108;
sh:minCount 1] ] ).
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Instance of is dissective on third argument, a temporal region [qaf-1]
#∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r)→instanceOf(p,q,s))
#This “should” work, but again I get a pretty much uninformative “something went wrong”

#temporal part of (bfo:0000139) bfo:existsat (bfo:0000108) bfo:temporalregion (bfo:0000008)

ex:instance_dissective_temporal_region_qas-1
a sh:NodeShape ;
sh:targetClass bfo:entity;
    sh:or (
          [sh:not [
          sh:targetSubjectsOf rdf:type;
          sh:property [
          sh:path bfo:0000108;
          sh:minCount 1
            ];
          sh:and [sh:property [ sh:path [ sh:inversePath bfo:0000108 ];
sh:minCount 1 ];];
          sh:and [ sh:property [ sh:path bfo:0000139; sh:minCount 1];]
          ];]
          [sh:targetObjectsOf bfo:0000139; sh:property [ sh:path
          [ sh:inversePath bfo:0000108 ]; sh:minCount 1
      ]; ] ).
```

```
#Relata of exists at are particulars. [oap-1]
#∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r)→instanceOf(p,q,s))
#bfo:existsat (bfo:0000108) bfo:temporalregion (bfo:0000008)

ex:relata_of_existence_are_particulars_oap-1
a sh:NodeShape ;
sh:targetClass bfo:Entity ;
sh:or ([ sh:not [
sh:property [
sh:path bfo:0000108; ]] ]    
[ sh:property   [      
sh:path bfo:0000108;
sh:minCount 1; 
sh:hasValue bfo:0000008;
] ]  ) .
```

```
#Relata of instance of are particular, universal, temporal region. [lqn-1]
#∀i,u,t(instanceOf(i,u,t)→particular(i)∧universal(u)∧instanceOf(t,temporalRegion,t))

ex:instance_of_relata_lqn-1
a sh:NodeShape ;
sh:targetSubjectsOf rdf:type ;
sh:property [sh:path bfo:0000108;
 sh:minCount 1 ;    ].
```

```
#There is always something that exists [nis-1]
#∀t(instanceOf(t,temporalRegion,t)→∃u,i(i̸=t∧universal(u)∧particular(i)∧instanceOf(i,u,t)))

ex:something_exists_nis-1
a sh:NodeShape ;
sh:targetClass bfo:0000008 ;
sh:property [sh:path [sh:inversePath bfo:0000108]
 sh:minCount 1 ;    ].
```

```
#If m is a material entity, then there is some one dimensional temporal region during which m exists [zuw-1]
#∀m(∃tinstanceOf(m,materialEntity,t)→∃t(instanceOf(t,oneDimensionalTemporalRegion,t)∧existsAt(m,t)))

 ex:material_entities_exist_at_time_zuw-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000040;
    sh:property [
    sh:path bfo:0000108; 
    sh:minCount 1;
        ].
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#If you exist you instatiate a universal and vice versa [bee-1]
#∀a,t(∃u(universal(u)∧instanceOf(a,u,t)∧instanceOf(t,temporalRegion,t))↔particular(a)∧instanceOf(t,temporalRegion,t)∧existsAt(a,t))
#I think this should work but the bfo shacl program tells me the quite uninformative “error”. So it’s not a syntax problem, otherwise it would have told me. 

ex:existence_instantiates_universals_bee-1
    a sh:NodeShape ;
        sh:targetClass bfo:0000001 ; 
        sh:or ([ sh:not [
sh:property [
sh:path bfo:0000108; ]]]    
[ sh:property   [      
sh:path rdf:type;
sh:minCount 1;
] ] );
sh:and [
sh:or ([ sh:not [
sh:property [
sh:path rdf:type; ]]]    
[ sh:property   [      
sh:path bfo:0000108;
sh:minCount 1; 
sh:hasValue bfo:0000008;
] ] )] .
```

___

**BFO 2020 Generic Dependence Axioms (9 axioms): Finn Wilson**

```
#Concretizes and is concretized by are inverse relations [zba-1]
#∀t,a,b(concretizes(a,b,t)↔isConcretizedBy(b,a,t))
#Concretizes at some time (bfo:0000059), Is concretized by at some time (bfo:0000058), Entity (bfo:0000001)

ex:zba-1 a sh:NodeShape ;
    sh:targetClass bfo:0000001 ;
    sh:property [
        sh:path bfo:0000059 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000058 ;
        sh:message "Concretizes and is concretized by are inverse relations"
    ] ;
    sh:property [
        sh:path bfo:0000058 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000059 ;
        sh:message "Concretizes and is concretized by are inverse relations"
    ] .
```

```
#Generically depends on and is carrier of are inverse relations [mvp-1]
#∀t,a,b(genericallyDependsOn(a,b,t)↔isCarrierOf(b,a,t))
	#Generically depends on at some time (bfo:0000084), Is carrier of at some time (bfo:0000101), generically dependent continuant (bfo:0000031)

ex:mvp-1 a sh:NodeShape ;
    sh:targetClass bfo:0000031 ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000101 ;
        sh:message "Generically depends on and is carrier of are inverse relations"
    ] ;
    sh:property [
        sh:path bfo:0000101 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000084 ;
        sh:message "Generically depends on and is carrier of are inverse relations"
    ] .
```

```
#Concretizes is dissective on third argument, a temporal region [nyz-1]
#∀p,q,r,s(concretizes(p,q,r)∧temporalPartOf(s,r)→concretizes(p,q,s))
#Concretizes at some time (bfo:0000059), Has temporal part (bfo:0000121), Temporal region (bfo:0000008), Temporal part of (bfo:0000139), Entity (bfo:0000001)

ex:nyz-1 a sh:NodeShape ;
    sh:targetClass bfo:0000001 ;
    sh:property [
        sh:path bfo:0000059 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Concretizes is dissective on third argument, a temporal region"
    ] ;
    sh:property [
        sh:path bfo:0000121 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:node bfo:0000008 ;
        sh:message "Concretizes is dissective on third argument, a temporal region"
    ] .

ex:nyz-1 a sh:NodeShape ;
    sh:targetClass bfo:0000008 ;
    sh:property [
        sh:path bfo:0000139 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000121 ;
        sh:message "Concretizes is dissective on third argument, a temporal region"
    ] .
```

```
#A generically dependent continuant is at all times at which it exists concretized by something [ibk-1]
#∀t,g(instanceOf(g,genericallyDependentContinuant,t)→∃s,tp(temporalPartOf(tp,t)∧concretizes(s,g,tp)))
#Continuant (bfo:0000002), Generically Dependent Continuant (bfo:0000031), Has temporal part (bfo:0000121), Is concretized by at some time (bfo:0000058), Temporal part of (bfo:0000139), Temporal Instant (bfo:0000203), Temporal Region (bfo:0000008)


ex:ibk-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000203 ;
        sh:in (bfo:0000031) ;
        sh:message "A generically dependent continuant is at all times at which it exists concretized by something"
    ] ;
    sh:property [
        sh:path bfo:0000121 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:node bfo:0000008 ;
        sh:message "A generically dependent continuant is at all times at which it exists concretized by something"
    ] ;
    sh:property [
        sh:path bfo:0000058 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A generically dependent continuant is at all times at which it exists concretized by something"
    ] .

ex:ibk-1 a sh:NodeShape ;
    sh:targetClass bfo:0000139 ;
    sh:property [
        sh:path bfo:0000139 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000121 ;
        sh:message "A generically dependent continuant is at all times at which it exists concretized by something"
    ] .

ex:ibk-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000031 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A generically dependent continuant is at all times at which it exists concretized by something"
    ] .
```

```
#A g dependent continuant b g depends on an independent continuant c at t means: there inheres in c at t an s dependent continuant which concretizes b at t [otx-1]
#∀g,c,t(genericallyDependsOn(g,c,t)→∃s,tp(temporalPartOf(tp,t)∧inheresIn(s,c)∧concretizes(s,g,tp)))
#Continuant (bfo:0000002), Temporal Instant (bfo:0000203), Generically Dependent Continuant (bfo:0000031), Generically Depends on at some time (bfo:0000084), Has Temporal Part (bfo:0000121), Temporal Region (bfo:0000008), Inheres In (bfo:0000197), Concretizes at some time (bfo:0000059), Temporal Part of (bfo:0000139), Has Continuant Part at some time (bfo:0000178)

ex:otx-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000203 ;
        sh:in (bfo:0000031) ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] ;
    sh:property [
        sh:path bfo:0000121 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:node bfo:0000008 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] ;
    sh:property [
        sh:path bfo:0000197 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] ;
    sh:property [
        sh:path bfo:0000059 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] .

ex:otx-1 a sh:NodeShape ;
    sh:targetClass bfo:0000139 ;
    sh:property [
        sh:path bfo:0000139 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:inversePath bfo:0000121 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] .

ex:otx-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] ;
    sh:property [
        sh:path bfo:0000178 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] .

ex:otx-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000178 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] .

ex:otx-1 a sh:NodeShape ;
    sh:targetClass bfo:0000002 ;
    sh:property [
        sh:path bfo:0000197 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A g dependent continuant depends on an independent continuant at a time"
    ] .
```

```
#Concretizes is time indexed and has domain: specifically dependent continuant or process and range: generically dependent continuant [rog-1]
#∀a,b,t(concretizes(a,b,t)→(instanceOf(a,specificallyDependentContinuant,t)∨instanceOf(a,process,t))∧instanceOf(b,genericallyDependentContinuant,t)∧instanceOf(t,temporalRegion,t))
#Concretizes at some time (bfo:0000059), Specifically Dependent Continuant (bfo:0000020), Generically Dependent Continuant (bfo:0000031), Temporal Region (bfo:0000008), Process (bfo:0000015)

ex:rog-1 a sh:NodeShape ;
		sh:targetClass [ sh:or (   	bfo:0000020    	bfo:0000015	) ] ;
		sh:property [
	    	sh:path bfo:0000059 ;
	    	sh:datatype xsd:anyURI ;
	    	sh:minCount 1 ;
	    	sh:maxCount 1 ;
	    	sh:qualifiedValueShape [
	        	sh:property [
	            	sh:path rdf:type ;
	            	sh:or ( bfo:0000031 ) ;
	            	sh:nodeKind sh:IRI ;
	            	sh:minCount 1 ;
	            	sh:maxCount 1 ;
	        	] ;
	        	sh:property [
	            	sh:path rdf:type ;
	            	sh:or ( bfo:0000008 ) ;
	            	sh:nodeKind sh:IRI ;
                                               sh:minCount 1 ;
	            	sh:maxCount 1 ;
	        	] ;
	    	] ;
		] . 
```

```
#Generically depends on is time indexed and has domain: generically dependent continuant and range: independent continuant but not spatial region [ekp-1]
#∀a,b,t(genericallyDependsOn(a,b,t)→instanceOf(a,genericallyDependentContinuant,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))
#Generically Dependent Continuant (bfo:0000031), Generically Depends on at some time (bfo:0000084), Independent Continuant (bfo:0000004), Spatial Region (bfo:0000006), Temporal Region (bfo:0000008)

ex:ekp-1 a sh:NodeShape ;
    sh:targetClass bfo:0000031 ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:datatype xsd:anyURI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:qualifiedValueShape [
            sh:property [
                sh:path rdf:type ;
                sh:or ( bfo:0000004 ) ;
                sh:not [ sh:path rdf:type ; sh:or ( 0000006 ) ] ;
                sh:nodeKind sh:IRI ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
            ] ;
            sh:property [
                sh:path rdf:type ;
                sh:or ( bfo:0000008 ) ;
                sh:nodeKind sh:IRI ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
            ] ;
        ] ;
    ] .
```

```
#If a specifically dependent continuant concretizes a gdc then the gdc generically depends on the bearer of the sdc [cik-1]
#∀g,b,sdc(∃tinstanceOf(g,genericallyDependentContinuant,t)∧∃tinstanceOf(sdc,specificallyDependentContinuant,t)∧∃tinstanceOf(b,independentContinuant,t)→∀t(concretizes(sdc,g,t)∧inheresIn(sdc,b)→genericallyDependsOn(g,b,t)))
#Concretizes at some time (bfo:0000059), Generically Dependent Continuant (bfo:0000031), Generically Depends on at some time (bfo:0000084), Independent Continuant (bfo:0000004), Inheres In (bfo:0000197), Specifically Dependent Continuant (bfo:0000020)

ex:cik-1 a sh:NodeShape ;
    sh:property [
        sh:path bfo:0000059 ;
        sh:datatype xsd:anyURI ;
        sh:qualifiedValueShape [
            sh:property [
                sh:path rdf:type ;
                sh:or ( bfo:0000031 ) ;
                sh:nodeKind sh:IRI ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
            ] ;
            sh:property [
                sh:path bfo:0000084 ;
                sh:nodeKind sh:IRI ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:qualifiedValueShape [
                    sh:property [
                        sh:path rdf:type ;
                        sh:or ( bfo:0000004 ) ;
                        sh:nodeKind sh:IRI ;
                        sh:minCount 1 ;
                        sh:maxCount 1 ;
                    ] ;
                ] ;
            ] ;
            sh:property [
                sh:path bfo:0000197 ;
                sh:nodeKind sh:IRI ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:qualifiedValueShape [
                    sh:property [
                        sh:path rdf:type ;
                        sh:or ( bfo:0000020 ) ;
                        sh:nodeKind sh:IRI ;
                        sh:minCount 1 ;
                        sh:maxCount 1 ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] .
```

```
#If a generically dependent continuant participates in a process p then, if it is concretized as a process, that process is part of p, fand if concretized as an sdc then the bearer of that sdc participates in the process [fmm-1]
#∀gdc,p,t(instanceOf(gdc,genericallyDependentContinuant,t)∧participatesIn(gdc,p,t)→∃tp,b(temporalPartOf(tp,t)∧concretizes(b,gdc,tp)∧((instanceOf(b,specificallyDependentContinuant,tp)∧(∃ic(specificallyDependsOn(b,ic)∧participatesIn(ic,p,tp))))∨(occurrentPartOf(b,p)∧existsAt(b,tp))))
#Generically Dependent Continuant (bfo:0000031), Participates in at some time (bfo:0000056), Process (bfo:0000015), Concretizes at some time (bfo:0000059), Member part of at some times (bfo:0000129), Has Member part of at some times (bfo:0000172), Specifically Dependent Continuant (bfo:0000020); Bearer Of (bfo:0000196), Participates in at some time (bfo:0000056)

ex:fmm-1 a sh:NodeShape ;
    rdf:type sh:NodeShape ;
    sh:targetClass bfo:0000031 ;
    sh:property [
        sh:path bfo:0000056 ;
        sh:node bfo:0000015
    ] ;
    sh:property [
        sh:path bfo:0000059 ;
        sh:or (
            [sh:class bfo:0000015 ;
             sh:property [
                 sh:path bfo:0000129 ;
                 sh:inversePath bfo:0000172
             ]]
            [sh:class bfo:0000020 ;
             sh:property [
                 sh:path bfo:0000196 ;
                 sh:property [
                     sh:path bfo:0000056 ;
                     sh:in bfo:0000015
                 ]
             ]]
        )
    ] .
```

___

**BFO 2020 History Axioms (8 axioms): Olivia Hobai**

```
#History of (bfo:0000184) and has history (bfo:0000185) are inverse relations [abx-1]
#∀a,b(historyOf(a,b)↔hasHistory(b,a))
Ex:abx-1

    a sh:NodeShape ;
    sh:targetClass bfo:0000182 ;
    sh:property [
        sh:path bfo:0000184 ;
        sh:inversePath bfo:0000185 ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "The historyOf property must have a corresponding hasHistory property."
    ] ;
    sh:property [
        sh:path bfo:0000185 ;
        sh:inversePath BFO:0000184 ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "The hasHistory property must have a corresponding historyOf property."
```

```
#History of (bfo:0000184) is functional on second argument [zek-1]
#∀p,q,r(historyOf(p,q)∧historyOf(p,r)→q=r)
#bfo:0000117 means ‘has occurrent part’

ex:zek-1
 a sh:NodeShape ;
    sh:targetClass bfo:0000001 ;
    sh:property [
        sh:path bfo:0000117 ;
        sh:nodeKind sh:BlankNodeOrIRI ;
        sh:property [
            sh:path bfo:0000184 ;
            sh:nodeKind sh:BlankNodeOrIRI ;
            sh:property [
                sh:path bfo:0000184 ;
                sh:nodeKind sh:BlankNodeOrIRI ;
                sh:property [
                    sh:path bfo:0000117 ;
                    sh:equalsPath bfo:0000117 ;
                    sh:message "The value of the second argument of the historyOf property is not unique."
                ]
            ]
        ]
    ] .
```

```
#Every material entity (bfo:0000040) has a history (bfo:0000182) [okt-1]
#∀m(∃instanceOf(m,materialEntity,t)→∃historyOf(h,m))
#bfo:0000185 means ‘has history’

ex:okt-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000040 ;
  sh:property [
    sh:path bfo:0000185 ;
    sh:minCount 1 ;
    sh:class bfo:0000182
  ] .
```

```
#Every history (bfo:0000182) is the history of something (bfo:0000040) [vvy-1]
#∀h(∃tinstanceOf(h,history,t)→∃m historyOf(h,m))
#bfo:0000184 means ‘history of’

ex:vvy-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000182 ;
  sh:property [
    sh:path bfo:0000184 ;
    sh:minCount 1 ;
    sh:class bfo:0000040
  ] .
```

```
#A material entity (bfo:0000040) participates in (bfo:0000166) its history [lga-1]
#∀h,m(historyOf(h,m)→∀t(existsAt(m,t)→participatesIn(m,h,t)))
#bfo:0000166 means ‘participates in at all times’

ex:lga-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000040 ;
  sh:property [
    sh:path bfo:0000184 ;
    sh:class bfo:0000182 ;
    sh:inversePath bfo:0000166
  ] .
```

```
#History of (bfo:0000184) is functional on first argument [woe-1]
#∀p,q,r(historyOf(p,q)∧historyOf(r,q)→p=r)

ex:woe-1 a sh:NodeShape ;
  sh:property [
    sh:path bfo:0000184 ;
    sh:node bfo:0000184 ;
    sh:severity sh:Violation ;
    sh:message "The property historyOf has multiple values for the second argument."
  ] ;
  sh:property [
    sh:path bfo:0000184 ;
    sh:maxCount 1 ;
    sh:severity sh:Violation ;
    sh:message "The property historyOf has multiple values for the first argument."
  ] .
```

```
# History of has domain history (bfo:0000182) and range material entity (bfo:0000040) [rph-1]
#∀a,b(historyOf(a,b)→∃instanceOf(a,history,t)∧∃instanceOf(b,materialEntity,t)

ex:rph-1
    a sh:NodeShape ;
    sh:targetSubjectsOf bfo:0000184 ;
    sh:property [
        sh:path rdf:type ;
        sh:in (bfo:0000182)
    ] ;
    sh:property [
        sh:path rdf:type ;
        sh:in (bfo:0000040)
    ] ;
    sh:property [
        sh:path rdf:type ;
        sh:class bfo:0000182
    ] .
```

```
#Material entity and its history exist at exactly the same times [uzz-1]
#∀m,h(historyOf(h,m)→∀t(instanceOf(m,materialEntity,t)↔instanceOf(h,history,t)))

ex:uzz-1 a sh:NodeShape ;
    rdf:type sh:NodeShape ;
    sh:targetClass bfo:0000040 ;
    sh:property [
        sh:path bfo:0000185 ;
        sh:minCount 1 ;
        sh:node bfo:0000182
    ] ;
    sh:property [
        sh:path bfo:0000185 ;
        sh:maxCount 1 ;
        sh:node bfo:0000182
    ] .

ex:uzz-1 a sh:NodeShape ;
    rdf:type sh:NodeShape ;
    sh:targetClass bfo:0000184 ;
    sh:property [
        sh:path bfo:0000184 ;
        sh:minCount 1 ;
        sh:node bfo:0000040
    ] ;
    sh:property [
        sh:path bfo:0000185 ;
        sh:maxCount 1 ;
        sh:node bfo:0000040
    ] .
```

___

**BFO 2020 Material Entity Axioms (11 axioms): Jaron Cheung**

```
#Member part of and has member part are inverse relations [jrm-1]
#∀t,a,b(memberPartOf(a,b,t)↔hasMemberPart(b,a,t))
#Entity (bfo:0000001), Member part of at some time (bfo:0000129), has member part at some time (bfo:0000115)

ex:jrm-1 a sh:NodeShape ;
        sh:targetClass bfo:0000001 ;
        sh:and (
        sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000129 ] ] ]
              [ sh:property   [ sh:path [ sh:inversePath bfo:0000115 ] ;
                                  sh:minCount 1 ] ] ) 
        sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000115 ] ] ]
              [ sh:property   [ sh:path [ sh:inversePath bfo:0000129 ] ;
                                  sh:minCount 1 ] ] ) 
        ).
```

```
#Member part of is dissective on third argument, a temporal region [yip-1]
#∀p,q,r,s(memberPartOf(p,q,r)∧temporalPartOf(s,r)→memberPartOf(p,q,s))
#Entity (bfo:0000001), member part of at some time (bfo:0000129), temporal part of (bfo:0000139), temporal region (bfo:0000008)
 
ex:yip-1 a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000001 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:nodeKind sh:IRI ;
        sh:qualifiedMinCount 3 ;
        sh:qualifiedMaxCount 3 ;
        sh:property [
            sh:path bfo:0000129 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000001 ;
        ] ;
        sh:property [
            sh:path bfo:0000129 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000008 ;
            sh:disjoint [
                sh:path bfo:0000139 ;
                sh:hasValue :yip-1 ;
            ]
        ]
    ] .
```

```
#An object aggregate always has at least one member [uhs-1]
#∀ag,t(instanceOf(ag,objectAggregate,t)→∃o1(instanceOf(o1,object,t)∧membePartOf(o1,ag,t)))
#Object aggregate (bfo:0000027), object (bfo:0000030), (Member part of at all times
(bfo:0000173).
 
ex:uhs-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000027 ;
    sh:property [
        sh:path bfo:0000027 ;
        sh:nodeKind sh:IRI ;
        sh:minCount 1 ;
        sh:property [
            sh:path bfo:0000173 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ] ;
        sh:property [
            sh:path bfo:0000030 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ]
    ] .
```

```
#Member part of is time indexed and has domain: object and range: object aggregate [dvq-1]
#∀a,b,t(memberPartOf(a,b,t)→instanceOf(a,object,t)∧instanceOf(b,objectAggregate,t)∧instanceOf(t,temporalRegion,t))
#Entity (bfo:0000001), member part of at some time (bfo:0000129), object (bfo:0000030), objectAggregate (bfo:0000027), temporal region (bfo:0000008)
 
ex:dvq-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000001 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:nodeKind sh:IRI ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000030 ;
        ] ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ] ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000008 ;
        ]
    ] .
```

```
#A fiat object part =def a proper part of an object [yir-1]
#∀f,t(instanceOf(f,fiatObjectPart,t)↔∃o(instanceOf(o,object,t)∧properContinuantPartOf(f,o,t)∧¬instanceOf(f,immaterialEntity,t)))
#Fiat object property (bfo:0000024), object (bfo:0000030), proper continuant part of at some time (bfo:0000175), immaterial entity (bfo:0000141)

ex:yir-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000024 ;
  sh:property [
    sh:path bfo:0000030 ;
    sh:nodeKind sh:IRI ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:hasValue bfo:0000024 ;
    ] ;
    sh:property [
      sh:path rdf:type ;
      sh:in (bfo:0000030) ;
    ] ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:maxCount 1 ;
    ] ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:not [        sh:path rdf:type ;        sh:in (bfo:0000141) ;      ] ;
    ] ;
  ] .
```

```
#I is an immaterial entity = Def. i is an independent continuant that has no material entities as parts. [udu-1]
#∀i,t(instanceOf(i,immaterialEntity,t)↔instanceOf(i,independentContinuant,t)∧¬(∃m(instanceOf(m,materialEntity,t)∧continuantPartOf(m,i,t))))
#Immaterial entity (bfo:0000141), independent continuant (bfo:0000004), material entity (bfo:0000040), continuant part of at all times (bfo:0000177).
 
ex:udu-1
  a sh:NodeShape ;
  sh:targetSubjectsOf bfo:0000141 ;
  sh:property [
    sh:path rdf:type ;
    sh:in (bfo:0000141) ;
  ] ;
  sh:property [
    sh:path rdf:type ;
    sh:in (bfo:0000004) ;
  ] ;
  sh:property [
    sh:path bfo:0000177 ;
    sh:nodeKind sh:BlankNodeOrIRI ;
    sh:minCount 0 ;
    sh:maxCount 1 ;
    sh:or (
      [
        sh:path rdf:type ;
        sh:in (bfo:0000040) ;
      ] 
      [        sh:path bfo:0000177 ;        sh:nodeKind sh:BlankNodeOrIRI ;        sh:maxCount 0 ;      ]
    )
  ] .
```

```
#Any continuant that doesn’t s depend or g depend on something is an independant continuant [ilw-1]
#∀c1(∃tinstanceOf(c1,independentContinuant,t)↔∃tinstanceOf(c1,continuant,t)∧¬(∃c2,t(specificallyDependsOn(c1,c2)∨genericallyDependsOn(c1,c2,t))))
	#Independent continuant (bfo:0000004), continuant (bfo:0000002), specifically depends on (bfo:0000195), generically depends on at some time (bfo:0000084)

ex:ilw-1
    a sh:NodeShape ;
    sh:targetSubjectsOf bfo:0000002 ;
    sh:property [
        sh:path bfo:0000195 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should not have specific dependency relation"
    ] ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should not have generic dependency relation"
    ] ;
    sh:property [
        sh:path (rdf:type) ;
        sh:hasValue bfo:0000004 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should be an instance of IndependentContinuant"
    ] .
```

```
#An object aggregate has more than one member at at least one time [ibd-1]
#∀ag(∃tinstanceOf(ag,objectAggregate,t)→∃o1,o2,t(o1̸=o2∧instanceOf(o1,object,t)∧memberPartOf(o1,ag,t)∧instanceOf(o2,object,t)∧memberPartOf(o2,ag,t)))
#ObjectAggregate (bfo:0000027), object (bfo:0000030), member part of at some time (bfo:0000129)

ex:ibd-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000027 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:minCount 2 ;
        sh:class bfo:0000030 ;
        sh:severity sh:Violation ;
        sh:message "ObjectAggregate should have at least 2 distinct members"
    ] .
```

```
#All parts of an aggregate overlap some member [fsy-1]
#∀t,b,x(properContinuantPartOf(x,b,t)∧instanceOf(b,objectAggregate,t)→∃o(memberPartOf(o,b,t)∧(∃z(continuantPartOf(z,x,t)∧continuantPartOf(z,o,t)))))
#Proper continuant part of at all times (bfo:0000137), object aggregate (bfo:0000027), object (bfo:0000030) member part of at some time (bfo:0000129), continuant part of at some time (bfo:0000176)

ex:fsy-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000137 ;
    sh:property [
        sh:path bfo:0000137 ;
        sh:in (bfo:0000027) ;
        sh:severity sh:Violation ;
        sh:message "ProperContinuant should be part of an ObjectAggregate"
    ] ;
    sh:property [
        sh:path (bfo:0000137 bfo:0000129) ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "All parts of an ObjectAggregate should overlap with at least one member"
    ] ;
    sh:property [
        sh:path ((bfo:0000137 bfo:0000176) bfo:0000129) ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "All proper continuant parts of an ObjectAggregate should overlap with at least one member"
    ] . 
```

```
#If a material entity has a proper part, then at least one of its proper parts is not an immaterial entity [adm-1]
#∀m,t(instanceOf(m,materialEntity,t)∧(∃mp(continuantPartOf(mp,m,t)∧mp̸=m))→∃mp(mp̸=m∧continuantPartOf(mp,m,t)∧¬instanceOf(mp,immaterialEntity,t)))
#Material entity (bfo:0000040), continuant part of at some time (bfo:0000176), immaterial entity (bfo:0000141)

ex:adm-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000040 ;
    sh:property [
        sh:path (bfo:0000176) ;
        sh:maxCount 1 ;
        sh:severity sh:Violation ;
        sh:message "Material entity should have at most one proper part"
    ] ;
    sh:property [
        sh:path (bfo:0000176) ;
        sh:or ([
            sh:path (bfo:0000176) ;
            sh:not (sh:class bfo:0000141) ;
            sh:severity sh:Violation ;
            sh:message "Material entity should not have immaterial proper part"
        ]) ;
        sh:severity sh:Violation ;
        sh:message "Material entity should have at least one proper part that is not an immaterial entity"
    ] .  
```

```
#An object aggregate has member parts only disjoint objects [evk-1]
#∀b,c,t(memberPartOf(b,c,t)↔instanceOf(b,object,t)∧instanceOf(c,objectAggregate,t)∧properContinuantPartOf(b,c,t)∧(∀d(memberPartOf(d,c,t)→b=d∨¬(∃z(continuantPartOf(z,b,t)∧continuantPartOf(z,d,t))))))
#Member part of at all times (bfo:0000173), object (bfo:0000030), object aggregate (bfo:0000027), Proper continuant part of at all times (bfo:0000137), continuant part of at some time (bfo:0000176)

ex:evk-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000173 ;
    sh:property [
        sh:path bfo:0000173 ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "Member part of an object aggregate should be an object"
    ] ;
    sh:property [
        sh:path (bfo:0000137 bfo:0000176) ;
        sh:in (bfo:0000027) ;
        sh:severity sh:Violation ;
        sh:message "Proper continuant part should be part of an object aggregate"
    ] ;
    sh:property [
        sh:path (bfo:0000173 bfo:0000176) ;
        sh:or ([
            sh:path (bfo:0000173 bfo:0000176) ;
            sh:equals sh:this ;
            sh:severity sh:Violation ;
            sh:message "Member part should not overlap with another member part"
        ]) ;
        sh:severity sh:Violation ;
        sh:message "Member part of an object aggregate should be disjoint from all other member parts"
    ] . 
```

___

**BFO 2020 Occurrent Mereology Axioms (23 axioms, 5 axioms not included in the final SHACL schema): Ali Hasanzadeh**

```
#Occurrent part of and has occurrent part are inverse relations [yvi-1]
#∀a,b(occurrentPartOf(a,b)↔hasOccurrentPart(b,a))
	#Occurent(bfo:0000003), occurentPartOf(bfo:0000132), hasOccurentPart(bfo:0000117)

ex:Oyvi-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        sh:path bfo:0000117 ;
        sh:inversePath bfo:0000132 ;
        sh:severity sh:Violation ;
        sh:message "The occurrent part relationship should be bidirectional." ;
    ] .
```

```
#Proper occurrent part of and has proper occurrent part are inverse relations [wim-1]
#∀a,b(properOccurrentPartOf(a,b)↔hasProperOccurrentPart(b,a))
#Occurent(bfo:0000003), hasProperOccurentPart(bfo:0000118), properOccurentPartOf(bfo:0000138)

ex:wim-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        sh:path bfo:0000118 ;
        sh:inversePath bfo:0000138 ;
        sh:severity sh:Violation ;
        sh:message "The proper occurrent part relationship should be bidirectional." ;
    ] .
```

```
#Occurrent part of is reflexive [hbj-1]
#∀a(∃t instanceOf(a,occurrent,t)→occurrentPartOf(a,a))
#Occurent(bfo:0000003), occurentPartOf(bfo:0000132)

ex:hbj-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000003 ;
  sh:property [
    sh:path bfo:0000132 ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:hasValue [ sh:path rdf:type ; sh:hasValue bfo:0000003 ]
  ] .
```

```
#Occurrent part of is antisymmetric [xlu-1]
#∀a,b(occurrentPartOf(a,b)∧occurrentPartOf(b,a)→a=b)
#Occurent(bfo:0000003), occurentPartOf(bfo:0000132)

ex:xlu-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        sh:path bfo:0000132 ;
        sh:nodeKind sh:IRI ;
        sh:inverses  bfo:0000132 ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "occurrentPartOf should be a symmetric relation"
    ] .
```

```
#A proper occurrent part of b means a is an occurrent part of b and a is not the same as b [okr-1]
#∀x,y(properOccurrentPartOf(x,y)↔occurrentPartOf(x,y)∧ x≠y)
#Occurent(bfo:0000003), occurentPartOf(bfo:0000132), properOccurentPartOf(bfo:0000138)

ex:okr-1
a sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        sh:path bfo:0000132 ;
        sh:nodeKind sh:IRI ;
        sh:class bfo:0000003
    ] ;
    sh:property [
        sh:path bfo:0000132 ;
        sh:maxCount 1 ;
        sh:nodeKind sh:IRI ;
        sh:inversePath bfo:0000138
    ] .
```

```
#Occurrent part of is transitive [kad-1]
#∀a,b,c(occurrentPartOf(a,b)∧occurrentPartOf(b,c)→occurrentPartOf(a,c))
	#Occurent(bfo:0000003), occurentPartOf(bfo:0000132)

ex:kad-1
    rdf:type sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        rdf:type sh:PropertyShape ;
        sh:path bfo:0000132 ;
        sh:node bfo:0000003 ;
        sh:severity sh:Violation ;
        sh:message "Violation of the transitivity axiom: {ex:occurrentPartOf}({0}, {1}) and {ex:occurrentPartOf}({1}, {2}), but not {ex:occurrentPartOf}({0}, {2})." ;
        sh:condition [
            rdf:type sh:SPARQLConstraint ;
            sh:message "SPARQL query for checking transitivity" ;
            sh:select """
                PREFIX ex: <http://example.org/onto#>
                ASK {
                    ?a bfo:0000132 ?b .
                    ?b bfo:0000132 ?c .
                    FILTER NOT EXISTS {
                        ?a bfo:0000132 ?c .
                    }
                }
            """ ;
        ] ;
    ] .
```

```
#If one occurrent is part of another, then the temporal region on which the former projects is a part of the temporal region on which the latter projects [ybr-1]
#∀o1,o2(occurrentPartOf(o1,o2)→∀t(existsAt(o1,t)→existsAt(o2,t)))
#occurentPartOf(bfo:0000132), existsAt(bfo:0000108)

ex:ybr-1
  a sh:NodeShape ;
    sh:property [
        sh:path bfo:0000132 ;
        sh:description "occurrentPartOf(o1,o2) -> existsAt(o1,t) -> existsAt(o2,t)" ;
        sh:severity sh:Violation ;
        sh:node [
            sh:property [
                sh:path bfo:0000108 ;
                sh:severity sh:Violation ;
                sh:message "o2 must exist at the same time as o1" ;
            ]
        ]
    ] .
```

```
#Occurrent part of has domain occurrent and range occurrent [zmr-1]
#∀a,b(occurrentPartOf(a,b)→∃tinstanceOf(a,occurrent,t)∧∃tinstanceOf(b,occurrent,t))

ex:zmr-1
  a sh:NodeShape ;
    sh:targetSubjectsOf bfo:0000132 ;
    sh:property [
      sh:path rdf:type ;
      sh:minCount 1 ;
      sh:node [
        sh:property [
          sh:path bfo:0000003 ;
          sh:hasValue true ;
        ]
      ]
    ] .
```

```
#If a occurrent part of b then if a is an instance of process then b is an instance of process [csk-1]
#∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,process,t)→∃tinstanceOf(q,process,t))

ex:csk-1
  a sh:NodeShape ;
  sh:targetSubjectsOf bfo:0000132 ;
  sh:property [
    sh:path rdf:type ;
    sh:minCount 1 ;
    sh:hasValue bfo:0000015 ;
  ] ;
  sh:property [
    sh:path rdf:type ;
    sh:minCount 1 ;
    sh:hasValue bfo:0000015 ;
    sh:in bfo:0000015 ;
  ] .
```

```
#Proper temporal part of has domain occurrent and range occurrent [ees-1]
#∀a,b(properTemporalPartOf(a,b)→∃tinstanceOf(a,occurrent,t)∧∃instanceOf(b,occurrent,t))
#Occurent(bfo:0000003), properTemporalPartOf(bfo:0000136), occuresIn(bfo:0000066), environs(bfo:0000183)

ex:ees-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000136 ;
    sh:property [
        sh:path bfo:0000183 ;
        sh:node [
            sh:property [
                sh:path rdf:type ;
                sh:hasValue bfo:0000003 ;
            ]
        ]
    ] ;
    sh:property [
        sh:path bfo:0000066 ;
        sh:node [
            sh:property [
                sh:path rdf:type ;
                sh:hasValue bfo:0000003 ;
            ]
        ]
    ] .
```

```
#Proper occurrent part of has domain occurrent and range occurrent [yhc-1]
#∀a,b(properOccurrentPartOf(a,b)→∃instanceOf(a,occurrent,t)∧∃instanceOf(b,occurrent,t))
#Occurent(bfo:0000003), properOccurentPartOf(bfo:0000138), 

ex:yhc-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000003 ;
    sh:property [
        sh:path bfo:0000138 ;
        sh:maxCount 1 ;
        sh:node [
            sh:property [
                sh:path rdf:type ;
                sh:minCount 2 ;
                sh:nodeKind sh:IRI ;
                sh:in (bfo:0000003)
            ]
        ]
    ] .
```

```
#Every process has a process boundary [aff-1]
#∀p(∃tinstanceOf(p,process,t)→∃pb,t(instanceOf(pb,processBoundary,t)∧occurrentPartOf(pb,p)))
#process(bfo:0000015), processBoundry(bfo:0000035), occurentPartOf(bfo:0000132)

ex:aff-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000015 ;
  sh:property [
    sh:path rdf:type ;
    sh:minCount 1 ;
    sh:node [
      sh:nodeKind sh:BlankNodeOrIRI ;
      sh:or ( [
        sh:class bfo:0000035 ;
        sh:property [
          sh:path bfo:0000132 ;
          sh:hasValue [ rdf:nodeID "this" ]
        ]
      ] )
    ]
  ] .
```

```
#If a occurrent part of b then if a is an instance of temporal region then b is an instance of temporal region, and vice versa [gjl-1]
#∀p,q(occurrentPartOf(p,q)→(∃t instanceOf(p,temporalRegion,t)↔∃t instanceOf(q,temporalRegion,t)))
#temporalRegion(bfo:0000008), occurentPartOf(bfo:0000132), 

ex:gjl-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000132 ;
    sh:property [
        sh:path rdf:type ;
        sh:or ([
            sh:inversePath bfo:0000132 ;
            sh:node bfo:0000008 ;
            sh:minCount 1 ;
        ] [            sh:inversePath bfo:0000132 ;            sh:node bfo:0000008 ;            sh:minCount 1 ;        ]) ;
    ] .
```

```
#If a has occurrent part b then if a is an instance of process boundary then b is an instance of process boundary [hdk-1]
#∀p,q(hasOccurrentPart(p,q)→(∃tinstanceOf(p,processBoundary,t)→∃tinstanceOf(q,processBoundary,t)))
#process(bfo:0000015), hasOccurentPart(bfo:0000117), processBoundry(bfo:0000035)

ex:hdk-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000015 ;
  sh:property [
    sh:path bfo:0000117 ;
    sh:minCount 1 ;
    sh:node [
      sh:property [
        sh:path rdf:type ;
        sh:hasValue bfo:0000035 ;
      ] ;
      sh:or [
        sh:property [
          sh:path rdf:type ;
          sh:hasValue bfo:0000035 ;
        ] ;
        sh:property [
          sh:path bfo:0000117 ;
          sh:node [
            sh:property [
              sh:path rdf:type ;
              sh:hasValue bfo:0000035 ;
            ]
          ]
        ]
      ]
    ]
  ] .
```

```
#If a occurrent part of b then if a is an instance of spatiotemporal region then b is an instance of spatiotemporal region, and vice versa [myl-1]
#∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,spatiotemporalRegion,t)↔∃t instanceOf(q,spatiotemporalRegion,t)))
#occurentPartOf(bfo:0000132), spatiotemporalRegion(bfo:0000011), hasPart(bfo:0000051)

ex:myl-1 a sh:NodeShape ;
  sh:targetClass bfo:0000132 ;
  sh:property [
    sh:path bfo:0000051 ;
    sh:node [
      sh:property [
        sh:path rdf:type ;
        sh:or ( 
          [ sh:class bfo:0000011 ]
          [ sh:nodeKind sh:blankNode ; 
            sh:property [
              sh:path rdf:type ; 
              sh:in ( bfo:0000011 )
            ] 
          ]
        )
      ]
    ]
  ] .

```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Definition of temporal part for temporal regions [cmy-1]
#∀b,c(∃tinstanceOf(b,temporalRegion,t)∧∃tinstanceOf(c,temporalRegion,t)→(temporalPartOf(b,c)↔occurrentPartOf(b,c)))
#temporalRegion(bfo:0000008), temporalPartOf(bfo:0000139), occurentPartOf(bfo:0000132)

ex:cmy-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000008 ;
    sh:property [
        sh:path bfo:0000139 ;
        sh:or (
            [ sh:class bfo:0000132 ]
            [ sh:node [
                sh:property [ sh:path rdf:type ; sh:hasValue bfo:0000132 ]
            ]]
        )
    ] .

ex:cmy-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000008 ;
  sh:property [
    sh:path bfo:0000139 ;
    sh:or ([
        sh:and ([
            sh:path rdf:type ;
            sh:hasValue bfo:0000008
          ]) ;
          sh:maxCount 1
        ])
  ], [
    sh:path bfo:0000132 ;
    sh:or ([
        sh:and ([
            sh:path rdf:type ;
            sh:hasValue bfo:0000008
          ]) ;
          sh:maxCount 1
        ])
  ], [
    sh:path bfo:0000139 ;
    sh:path bfo:0000132 ;
    sh:nodeKind sh:BlankNodeOr ;
    sh:or ([
        sh:and ([
            sh:path rdf:type ;
            sh:hasValue bfo:0000008
          ]) ;
          sh:maxCount 1
        ])
  ] .
```

```
#If a has occurrent part b then if a is an instance of process then b is an instance of process or process boundary [ccz-1]
#∀p,q(hasOccurrentPart(p,q)→(∃tinstanceOf(p,process,t)→∃t(instanceOf(q,process,t)∨instanceOf(q,processBoundary,t))))
#occurentPartOf(bfo:0000132), hasOccurrentPart(bfo:0000117), process(bfo:0000015), processBoundry(bfo:0000035)

ex:ccz-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000132 ;
    sh:property [
        sh:path bfo:0000117 ;
        sh:minCount 1 ;
        sh:qualifiedValueShape [
            sh:property [
                sh:path rdf:type ;
                sh:minCount 1 ;
                sh:qualifiedValueShape [
                    sh:or ([
                        sh:path rdf:type ;
                        sh:hasValue bfo:0000015
                    ] [
                        sh:path rdf:type ;
                        sh:hasValue bfo:0000035
                    ])
                ]
            ]
        ]
    ] .
```

```
#If a occurrent part of b then if a is an instance of process boundary then b is an instance of process or process boundary [ptm-1]
#∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,processBoundary,t)→∃t(instanceOf(q,process,t)∨instanceOf(q,processBoundary,t))))
#occurentPartOf(bfo:0000132), processBoundry(bfo:0000035), process(bfo:0000015)

ex:ptm-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000132 ;
  sh:property [
    sh:path bfo:0000035 ;
    sh:minCount 1 ;
    sh:class bfo:0000035
  ] ;
  sh:property [
    sh:path bfo:0000015 ;
    sh:minCount 1 ;
    sh:or ( 
      [ sh:class bfo:0000015 ] 
      [ sh:class bfo:0000035 ]
    )
  ] .
```

```
#A process boundary is any temporal part of a process that has no proper temporal parts. [esh-1]
#∀pb(∃tinstanceOf(pb,processBoundary,t)↔(∃p(temporalPartOf(pb,p)∧∃tinstanceOf(p,process,t)))∧(∃t(occupiesTemporalRegion(pb,t)∧instanceOf(t,temporalInstant,t))))
#occurentPartOf(bfo:0000132), processBoundry(bfo:0000035), process(bfo:0000015)

ex:esh-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000132 ;
  sh:property [
    sh:path bfo:0000035 ;
    sh:minCount 1 ;
    sh:class bfo:0000035
  ] ;
  sh:property [
    sh:path bfo:0000015 ;
    sh:minCount 1 ;
    sh:or ( 
      [ sh:class bfo:0000015 ] 
      [ sh:class bfo:0000035 ]
    )
  ] .
```

*The following 4 axioms do not have SHACL shapes completed for them. As such, the final SHACL schema file do not have SHACL shapes that encorde them.

#Occurrent part of has a unique product [hpc-1]
#∀x,y(∃t(instanceOf(x,occurrent,t)∧instanceOf(y,occurrent,t)∧instanceOf(t,temporalRegion,t))→(∃w(occurrentPartOf(w,x)∧occurrentPartOf(w,y))→∃z(∀w(occurrentPartOf(w,z)↔occurrentPartOf(w,x)∧occurrentPartOf(w,y)))))

#At least one process boundary needs to be at the first or last instant of the process it bounds [qsp-1]
#∀p(∃tpinstanceOf(p,process,tp)→∃pb,tb,tp(occupiesTemporalRegion(p,tp)∧occurrentPartOf(pb,p)∧occupiesTemporalRegion(pb,tb)∧instanceOf(pb,processBoundary,tb)∧(∃ltp,ftp(hasFirstInstant(tp,ftp)∧hasLastInstant(tp,ltp)∧(tb=ftp∨tb=ltp)))))

#B temporal part c (both spatiotemporal regions) iff b temporal projection is part of c’s temporal projection, and for all parts of b’s existence, if it spatially projects onto s at that time, then so does c [eom-1]
#∀b,c(∃tinstanceOf(b,spatiotemporalRegion,t)∧∃tinstanceOf(c,spatiotemporalRegion,t)→(temporalPartOf(b,c)↔∃tb,tc(temporallyProjectsOnto(b,tb)∧temporallyProjectsOnto(c,tc)∧occurrentPartOf(tb,tc)∧(∀tp(occurrentPartOf(tp,tb)∧∃sspatiallyProjectsOnto(b,s,tp)→∃s(spatiallyProjectsOnto(b,s,tp)∧spatiallyProjectsOnto(c,s,tp)))))))

#Two spatiotemporal regions are parts when they are temporal parts and their spatial projects are always parts [txf-1]
#∀st1,st2(∃tinstanceOf(st1,spatiotemporalRegion,t)∧∃tinstanceOf(st2,spatiotemporalRegion,t)→(occurrentPartOf(st1,st2)↔(∃t1,t2(temporallyProjectsOnto(st1,t1)∧temporallyProjectsOnto(st2,t2)∧temporalPartOf(t1,t2)))∧(∀t(existsAt(st1,t)→∃s1,s2,tp(temporalPartOf(tp,t)∧spatiallyProjectsOnto(st1,s1,tp)∧spatiallyProjectsOnto(st2,s2,tp)∧continuantPartOf(s1,s2,tp))))))

___

**BFO 2020 Order Axioms (16 axioms, 1 axiom not included in the final SHACL schema): Matthew Jones**

```
#Precedes and preceded by are inverse relations [tib-1]
#∀a,b(precedes(a,b)↔precededBy(b,a))
#Precedes (BFO:0000063), PrecededBy (BFO:0000062)
 
ex:PrecedesPrecededByShape_tib-1
	a sh:NodeShape ;
	sh:targetObjectsOf bfo:0000062 ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:inversePath bfo:0000062 ;
    	sh:message "The value of ex:precedes should be preceded by the value of ex:precededBy" ;
	] .
```

```
#Precedes is antisymmetric [hew-1]
#∀a,b(precedes(a,b)→¬precedes(b,a))
# Precedes (BFO:0000063), PrecededBy (BFO:0000062)
 
ex:PrecedesAntisymmetricShape _hew-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000003 ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:nodeKind sh:BlankNodeOrLiteral ;
    	sh:minCount 2 ;
    	sh:maxCount 2 ;
    	sh:message "The value of ex:precedes (bfo:0000063) is antisymmetric" ;
    	sh:property [
        	sh:path rdf:type ;
        	sh:in (
            	ex:PrecedesOrder
            	ex:PrecedesAntiOrder
        	) ;
        	sh:message "The values of ex:precedes (bfo:0000063) should form a valid order relation"
    	] ;
	] .
 
ex:PrecedesOrder
	a sh:NodeShape ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:lessThan bfo:0000062 ;
	] .
 
ex:PrecedesAntiOrder
	a sh:NodeShape ;
	sh:property [
    	sh:path bfo:0000062 ;
    	sh:lessThan bfo:0000063 ;
	] .
```

```
#Precedes is transitive [ctz-1]
#∀a,b,c(precedes(a,b)∧precedes(b,c)→precedes(a,c))
ex:PrecedesTransitiveShape_ctz-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000001 ;
	sh:property [
    	sh:path bfo:0000063;
    	sh:nodeKind sh:BlankNodeOrLiteral ;
    	sh:minCount 3 ;
    	sh:message "The value of ex:precedes is transitive" ;
    	sh:property [
        	sh:path rdf:type ;
        	sh:in (
            	ex:PrecedesOrder
            	ex:PrecedesTransitivity
        	) ;
        	sh:message "The values of ex:precedes (bfo:0000063) should form a valid order relation"
    	] ;
	] .
 
ex:PrecedesOrder
	a sh:NodeShape ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:lessThan bfo:0000062 ;
	] .
 
ex:PrecedesTransitivity
	a sh:NodeShape ;
	sh:property [
    	sh:path bfo:0000063 ;
        sh:lessThanOrEquals bfo:0000063 ;
	] ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:lessThan bfo:0000062 ;
	] .
```

```
#If the last instant of a temporal region precedes the first instant of another, then the first region precedes the second [qqv-1]
#∀i1,i2,l1,f2(hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧precedes(l1,f2)→precedes(i1,i2))
# Precedes (BFO:0000063), PrecededBy (BFO:0000062), hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221)
 
ex:TemporalRegionPrecedesShape_qqv-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000008 ;
	sh:property [
    	sh:path bfo:0000224 ;
    	sh:nodeKind sh:IRI ;
	] ;
	sh:property [
    	sh:path bfo:0000222 ;
    	sh:nodeKind sh:IRI ;
    	sh:property [
        	sh:path bfo:0000062 ;
        	sh:inversePath bfo:0000063;
        	sh:property [
            	sh:path bfo:0000224 ;
            	sh:nodeKind sh:IRI ;
            	sh:minCount 1 ;
        	] ;
    	] ;
	] ;
	sh:property [
    	sh:path bfo:0000062 ;
    	sh:inversePath bfo:0000063 ;
    	sh:property [
        	sh:path bfo:0000221 ;
        	sh:nodeKind sh:IRI ;
        	sh:minCount 1 ;
    	] ;
	] .
```

```
#Precedes has domain occurrent and range occurrent [sen-1]
#∀a,b(precedes(a,b)→∃tinstanceOf(a,occurrent,t)∧∃t instanceOf(b,occurrent,t))
# Precedes (BFO:0000063), PrecededBy (BFO:0000062), Occurrent (BFO:0000003)
 
bfo:precedesShape_sen-1
  a sh:NodeShape ;
  sh:targetSubjectsOf bfo:0000063 ;
  sh:property [
	sh:path rdf:type ;
	sh:in (bfo:0000003)
  ] ;
  sh:property [
	sh:path rdf:type ;
	sh:in (bfo:0000003)
  ] .
```

```
#If you are part of something that precedes something else, you also precede it [wix-1]
#∀o1,o2,o1p,o2p(occurrentPartOf(o1p,o1)∧occurrentPartOf(o2p,o2)∧precedes(o1,o2)→precedes(o1p,o2p))
	#Precedes (BFO:0000063), PrecededBy (BFO:0000062), Occurrent (BFO:0000003), OccurrentPartOf (BFO:0000132)
ex:PrecedesShape_wix-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000003 ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:minCount 1 ;
        sh:qualifiedValueShape [
        	sh:and ([
            	sh:path bfo:0000132 ;
                sh:inversePath bfo:0000063 ;
                sh:node bfo:0000003 ;
        	] [            	sh:path bfo:0000132 ;            	sh:node bfo:0000003 ;        	])
    	]
	] .
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#First instant of a temporal region that is not an instant precedes last instant [rzv-1]
#∀t,ft,lt(¬instanceOf(t,temporalInstant,t)∧hasFirstInstant(t,ft)∧hasLastInstant(t,lt)
→precedes(ft,lt))
# Precedes (BFO:0000063), TemporalRegion (BFO:0000008), hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221), TemporalInterval (BFO:0000202), FirstInstantOF (BFO:0000221), TemporalInstant (BFO:0000203), LastInstantOf (BFO:0000223)
#SOMETHING WENT WRONG
ex:TemporalRegionPrecedesShape_rzv-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000008 ;
	sh:property [
    	sh:path bfo:0000224 ;
    	sh:or ( [
            sh:nodeKind sh:blankNode ;
            sh:property [
                sh:path rdf:type ;
            	sh:in ( bfo:0000202 bfo:0000008 )
        	] ;
            sh:property [
                sh:path bfo:0000063 ;
            	sh:in ( bfo:0000221 )
        	]
    	] [
            sh:nodeKind sh:blankNode ;
        	sh:property [
                sh:path rdf:type ;
            	sh:in bfo:0000203
        	] ;
            sh:property [
            	sh:path bfo:0000063 ;
            	sh:in bfo:0000223
        	]
    	] ) ;
    	sh:minCount 1 ;
    	sh:message "The first instant of a temporal region that is not an instant must precede its last instant."
	] .
```

```
#If one temporal region precedes another then the first last time point precedes the second first time point [miz-1]
#∀t1,t2,l1,f2 (precedes(t1,t2)∧hasLastInstant(t1,l1)∧hasFirstInstant(t2,f2)∧l1̸=f2
→precedes(l1,f2))
# Precedes (BFO:0000063), hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221), TemporalRegion (BFO:0000008)
 
ex:TempRegionFirstSecondFirstPointShape_miz-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000008 ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:minCount 1 ;
    	sh:node ex:Miz1Constraint
	] .
 
ex:Miz1Constraint
	a sh:NodeShape ;
	sh:property [
    	sh:path bfo:0000224 ;
    	sh:nodeKind sh:IRI ;
    	sh:minCount 1 ;
    	sh:maxCount 1
	] ;
	sh:property [
    	sh:path bfo:0000221 ;
    	sh:nodeKind sh:IRI ;
    	sh:minCount 1 ;
    	sh:maxCount 1
	] ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:nodeKind sh:IRI ;
    	sh:minCount 1 ;
    	sh:severity sh:Violation ;
    	sh:message "The last time point of {ex:precedes} must precede the first time point of {ex:precedes}."
	] .
```

```
#If one occurrent precedes another then they do not overlap temporally [aou-1]
#∀p,q(precedes(p,q)∨precedes(q,p)→¬(∃overlap(temporalPartOf(overlap,p)∧temporalPartOf(overlap,q))))
#Precedes (BFO:0000063), PrecededBy (BFO:0000062), Occurrent (BFO:0000003), OccurrentPartOf (BFO:0000132), TemporalPartOf (BFO:0000203)
 
ex:OccurrentPrecedesShape_aou-1
  rdf:type sh:NodeShape ;
  sh:targetClass bfo:0000003 ;
  sh:property [
	sh:path bfo:0000203 ;
	sh:nodeKind sh:BlankNode ;
	sh:property [
  	sh:path ex:overlap ;
  	sh:nodeKind sh:BlankNode ;
  	sh:property [
    	sh:path bfo:0000203 ;
    	sh:or ([
      	sh:path bfo:0000063 ;
          sh:inversePath bfo:0000063
    	] [
      	sh:node bfo:0000003
    	])
  	]
	] ;
	sh:filterShape [
  	sh:path bfo:0000063 ;
  	sh:or ([
    	sh:path bfo:0000063
  	] [
    	sh:inversePath bfo:0000063
  	])
	] ;
	sh:maxCount 1 ;
	sh:message "If one occurrent precedes another then they do not overlap temporally"
  ] .
```

```
#Temporal instants are totally ordered [qnf-1]
#∀t1,t2(instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)→precedes(t1,t2)∨precedes(t2,t1)∨t1=t2)
# Precedes (BFO:0000063), TemporalInstant (BFO:0000203), Entity (BFO:0000001)
 
:TotalOrderShape_qnf-1
	rdf:type sh:NodeShape ;
	sh:targetClass bfo:0000203 ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:or (
        	[ sh:path bfo:0000063 ]
        	[ sh:path bfo:0000063 ; sh:minCount 1 ]
        	[ sh:path bfo:0000063 ; sh:maxCount 1 ]
        	[ sh:path rdf:type ; sh:hasValue bfo:0000203 ]
        	[ sh:path rdf:type ; sh:hasValue bfo:0000001l ]
    	)
	] .
```

```
#If the last instant of a temporal region is the first instant of another, the first region precedes the second [suk-1]
#∀i1,i2,l1,f2(¬instanceOf(i1,temporalInstant,i1)∧¬instanceOf(i2,temporalInstant,i2)∧hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧l1=f2→precedes(i1,i2))
# hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221), TemporalRegion (BFO:0000008), Precedes (BFO:0000063)
 
ex:LastFirstInstantPreceds_suk-1
	rdf:type sh:NodeShape ;
	sh:targetClass bfo:0000008 ;
	sh:property [
    	sh:path bfo:0000224 ;
    	sh:nodeKind sh:IRI ;
    	sh:property [
        	sh:path bfo:0000063 ;
            sh:inversePath bfo:0000221 ;
            sh:severity sh:Violation ;
            sh:message "The last instant of this temporal region should precede the first instant of the following region."
    	] ;
    	sh:property [
        	sh:path bfo:0000221 ;
            sh:nodeKind sh:IRI ;
            sh:maxCount 1 ;
            sh:severity sh:Violation ;
        	sh:message "A temporal region can only have one first instant."
    	]
	] .
```

```
#A last instant is either part of an extended region or is preceded by it [acg-1]
#∀l,i(instanceOf(l,temporalInstant,l)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasLastInstant(i,l)→(¬temporalPartOf(l,i)↔precedes(i,l)))
# Precedes (BFO:0000063), TemporalRegion (BFO:0000008), hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221), TemporalPartOf (BFO:0000139), TemporalInstant (BFO:0000203)
ex:TemporalRegionShape_acg-1
  a sh:NodeShape ;
  sh:targetClass ex:TemporalRegionShape ;
  sh:property [
    sh:path bfo:0000224 ;
	sh:or (
  	[
    	sh:not [
      	sh:path bfo:0000139 ;
      	sh:node bfo:0000008
    	] ;
    	sh:property [
      	sh:path bfo:0000221 ;
      	sh:nodeKind sh:IRI
    	]
 	 ]
  	[
    	sh:path bfo:0000139 ;
    	sh:node ex:TemporalRegionShape
  	]
	)
  ] .
 
ex:TemporalInstantShape
  a sh:NodeShape ;
  sh:targetClass bfo:0000203 ;
  sh:property [
	sh:path bfo:0000224 ;
	sh:nodeKind sh:BlankNode ;
	sh:property [
  	sh:path bfo:0000139 ;
  	sh:node ex:TemporalRegionShape
	] ;
	sh:property [
  	sh:path bfo:0000063 ;
  	sh:nodeKind sh:IRI
	]
  ] .
```

```
#A first instant is either part of an extended region or precedes it [qga-1]
#∀f,i(instanceOf(f,temporalInstant,f)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasFirstInstant(i,f)→(¬temporalPartOf(f,i) ↔precedes(f,i)))
# Precedes (BFO:0000063), TemporalRegion (BFO:0000008), hasLastInstant (BFO:0000224), hasFirstInstant (BFO:0000221), TemporalPartOf (BFO:0000139), TemporalInstant (BFO:0000203)

 ex:FirstInstantPartOfExtendedOrPrecedes_qga-1
	rdf:type sh:NodeShape ;
	sh:targetClass bfo:0000008 ;
	sh:property [
    	sh:path bfo:0000221 ;
    	sh:or ([
            sh:inversePath bfo:0000063 ;
        	sh:class bfo:0000203
    	] [
            sh:inversePath bfo:0000139 ;
     	   sh:class bfo:0000008
    	])
	] .
```

```
#If two temporal intervals do not overlap then one of them precedes the other [owb-1]
#∀t1,t2(instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(t1,t2)∨precedes(t2,t1))
# Precedes (BFO:0000063), HasTemporalPart (BFO:0000121), TemproalInterval (BFO:0000202)
ex:TemporalIntervalsPrecedeShape_owb-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000202 ;
	sh:property [
    	sh:path bfo:0000121 ;
    	sh:or (
   	     [
                sh:property [
                    sh:path bfo:0000063 ;
                    sh:inversePath bfo:0000063 ;
                    sh:minCount 1 ;
            	]
        	]
        	[            	sh:property [                	sh:path bfo:0000063 ;                	sh:minCount 1 ;            	]
        	]
    	)
	] .
```

```
#If you temporally occupy part of something that precedes something else, you also precede it [wff-1]
#∀o1,o2(∃t1,t2((occupiesTemporalRegion(o1,t1)∨temporallyProjectsOnto(o1,t1)∨t1=o1)∧(occupiesTemporalRegion(o2,t2)∨temporallyProjectsOnto(o2,t2)∨t2=o2)∧precedes(t1,t2))↔precedes(o1,o2))

# Precedes (BFO:0000063), OccupiesTemporalRegion (BFO:0000199), TemporallyProjectsOnto (BFO:0000153), Occurrent (BFO:0000003)

 ex:TemporalPrecedenceShape_wff-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000003 ;
	sh:property [
    	sh:path bfo:0000199 ;
    	sh:minCount 1 ;
    	sh:nodeKind sh:IRI ;
	] ;
	sh:property [
    	sh:path bfo:0000153 ;
    	sh:minCount 1 ;
    	sh:nodeKind sh:IRI ;
	] ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:minCount 1 ;
    	sh:nodeKind sh:IRI ;
	] ;
	sh:property [
    	sh:path bfo:0000063 ;
    	sh:minCount 1 ;
    	sh:nodeKind sh:IRI ;
    	sh:in (
        	[ sh:path bfo:0000199 ;
    	      sh:nodeKind sh:IRI ;
              sh:minCount 1 ;
        	] [ sh:path bfo:0000153 ;                sh:nodeKind sh:IRI ;                sh:minCount 1 ;        	]
    	) ;
	] .
```

```
#If two processes that occupy temporal intervals do not overlap, one of them precedes the other [duz-1]
#∀o1,o2,t1,t2(occupiesTemporalRegion(o1,t1)∧occupiesTemporalRegion(o2,t2)
∧instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(o1,o2)∨precedes(o2,o1))

# OccupiesTemporalRegion (BFO:0000199), TemporalInterval (BFO:0000202), TemporalPartOf (BFO:0000139); PrecededBy (BFO:0000062), Process (BFO:0000015)
ex:TemporalOverlapShape a sh:NodeShape ;
  sh:targetClass bfo:0000015 ;
  sh:property [
	sh:path bfo:0000199 ;
	sh:nodeKind sh:BlankNode ;
	sh:property [
  	sh:path bfo:0000202 ;
	  sh:class bfo:0000202 ;
  	sh:nodeKind sh:BlankNode ;
  	sh:property [
    	sh:path :part ;
    	sh:nodeKind sh:BlankNode ;
    	sh:property [
      	sh:path bfo:0000139 ;
      	sh:in (bfo:0000199) ;
      	sh:inversePath true ;
          sh:zeroOrMore true ;
    	] ;
    	sh:property [
      	sh:path bfo:0000139 ;
      	sh:in (bfo:0000199) ;
          sh:inversePath true ;
          sh:zeroOrMore true ;
    	] ;
  	] ;
	] ;
	sh:property [
  	sh:path bfo:0000062 ;
  	sh:class bfo:0000015 ;
  	sh:minCount 1 ;
	] ;
  ] .
```

___

**BFO 2020 Participation Axioms**

Participates in and has participant are inverse relations [xjr-1]
∀t,a,b(participatesIn(a,b,t) ↔hasParticipant(b,a,t))

At every time a process exists it has a participant [trl-1]
∀p,t(instanceOf(p,process,t) →∃c participatesIn(c,p,t))

Participates in is dissective on third argument, a temporal region [yjm-1]
∀p,q,r,s(participatesIn(p,q,r)∧temporalPartOf(s,r) →participatesIn(p,q,s))

Participates in is time indexed and has domain: independent continuant but not spatial region or specifically dependent continuant or generically dependent continuant and range: process [ild-1]
∀a,b,t(participatesIn(a,b,t)→((instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t))∨instanceOf(a,specificallyDependentContinuant,t)∨instanceOf(a,genericallyDependentContinuant,t))∧instanceOf(b,process,t)∧instanceOf(t,temporalRegion,t))

At every time a specific dependent s participates in a process p there’s a part of that time, during which there’s an independent continuant that s s depends on, and that participates in p at that time [cgn-1]
∀sdc,p,t(instanceOf(sdc,specificallyDependentContinuant,t)∧participatesIn(sdc,p,t)→∃tp,ic(instanceOf(tp,temporalRegion,tp)∧temporalPartOf(tp,t)∧instanceOf(ic,independentContinuant,tp)∧¬instanceOf(ic,spatialRegion,tp)∧specificallyDependsOn(sdc,ic)∧participatesIn(ic,p,tp)))

If a generically dependent continuant participates in a process p then, if it is concretized as a process, that process is part of p, fand if concretized as an sdc then the bearer of that sdc participates in the process [fmm-1]
∀gdc,p,t(instanceOf(gdc,genericallyDependentContinuant,t)∧participatesIn(gdc,p,t)→∃tp,b(temporalPartOf(tp,t)∧concretizes(b,gdc,tp)∧((instanceOf(b,specificallyDependentContinuant,tp)∧(∃ic(specificallyDependsOn(b,ic)∧participatesIn(ic,p,tp))))∨(occurrentPartOf(b,p)∧existsAt(b,tp))))

___

**BFO 2020 Spatial Axioms (4 completed axioms): Tim Prudhomme**

```
#Occurs in and environs are inverse relations [uys-1]
#∀a,b(occursIn(a,b)↔environs(b,a))

bfo:uys-1 a sh:NodeShape ;
       sh:resultSeverity sh:Violation ;
       sh:message "Occurs in and environs are inverse relations" ;
       rdfs:comment "∀a,b(occursIn(a,b)↔environs(b,a))"
       sh:targetSubjectsOf bfo:0000183 ;
       sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000183 ] ] ]
               [ sh:property   [ sh:path [ sh:inversePath bfo:0000066 ] ;
                                 sh:minCount 1 ] ] ) .
```

```
# Located in and location of are inverse relations [kaw-1]
# ∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))

bfo:kaw-1-2 a sh:NodeShape ;
      sh:resultSeverity sh:Violation ;
      sh:message "Located in and location of are inverse relations" ;
      rdfs:comment "∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))"
      sh:targetSubjectsOf bfo:0000124 ; # location OF at some time
      sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000124 ] ] ]
              [ sh:property   [ sh:path [ sh:inversePath bfo:0000171 ] ;
                                sh:minCount 1 ] ] ) .
```

```
# Occurs in is dissective on first argument when it is an occurrent [jil-1]
# ∀p,q,r(occursIn(p,q)∧occurrentPartOf(r,p)→occursIn(r,q))

# This references the PropertyShape for “occurs in” in the BFO SHACL schema generated by Astrea (probably should change the IRI)
# This adds more conditions to that same PropertyShape
# Copied from Ali but I wasn’t able to test this

ex:jil-1
   sh:message   "Violation of the dissectivity axiom: {ex:occursIn}({0}, {1}) and {ex:occurrentPartOf}({2}, {0}), but not {ex:occursIn}({2}, {1})." ;
   sh:condition [
       rdf:type sh:SPARQLConstraint ;
       sh:message "SPARQL query for checking dissectivity" ;
       sh:select """ ASK {
                 ?p bfo:0000066 ?q .
                 ?r bfo:0000132 ?p .
                 FILTER NOT EXISTS {
                       ?r bfo:0000066 ?q .
                   }
               } """ ;
    ] .
```

```
# Located in is dissective on third argument, a temporal region [put-1]
# ∀p,q,r,s(locatedIn(p,q,r)∧temporalPartOf(s,r)→locatedIn(p,q,s))
# Step 1. First convert to ∀p,q,r,s(¬(locatedIn(p,q,r)∧temporalPartOf(s,r)) ∨ locatedIn(p,q,s)) ...

bfo:put-1 a sh:NodeShape ;
      sh:resultSeverity sh:Violation ;
      sh:message "Located in is dissective on third argument, a temporal region" ;
      rdfs:comment "∀p,q,r,s(locatedIn(p,q,r)∧temporalPartOf(s,r)→locatedIn(p,q,s))" ;
      rdfs:comment "If Raleigh is located in NC at 1990, and 1990 is part of 20th century, then Raleigh is located in NC at 20th century" ;
      sh:targetSubjectsOf bfo:0000171 ; # located in at some time
      sh:or ( [ sh:not [ sh:and ( [ sh:property [ sh:path bfo:0000171 ] ]
                                  [ sh:property [ sh:path bfo:0000139 ] ] ) ] ]
              [ sh:property [ sh:path bfo:0000171 ] ] ) .
```

Located in is a lower bound on second argument [evu-1]
∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(q,s,r)→locatedIn(p,s,r))

Located in is dissective on first argument when it is a continuant [wty-1]
∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(s,p,r)→locatedIn(s,q,r))

Occupies spatial region is functional on second argument [zls-1]
∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧occupiesSpatialRegion(p,s,r) →q=s)

Occupies spatial region is dissective on third argument, a temporal region [mud-1]
∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧temporalPartOf(s,r)→occupiesSpatialRegion(p,q,s))

Spatially projects onto is dissective on third argument, a temporal region [ivt-1]
∀p,q,r,s(spatiallyProjectsOnto(p,q,r)∧temporalPartOf(s,r)→spatiallyProjectsOnto(p,q,s))

Located in is transitive at a time [xlm-1]
∀a,b,c,t,t2(locatedIn(a,b,t)∧locatedIn(b,c,t2)∧temporalPartOf(t,t2)→locatedIn(a,c,t))

If a location of b then if a is an instance of continuant fiat boundary then b is an instance of continuant fiat boundary [wte-1]
∀p,q,t(locationOf(p,q,t)∧instanceOf(p,continuantFiatBoundary,t)→instanceOf(q,continuantFiatBoundary,t))

All spatial regions are part of a 3 dimensional spatial region [xcx-1]
∀s,t(instanceOf(s,spatialRegion,t)→∃s3(instanceOf(s3,threeDimensionalSpatialRegion,t)∧continuantPartOf(s,s3,t)))

Occurs in is lower bound location [czc-1]
∀p,c1,c2(occursIn(p,c1)∧(∀t(existsAt(p,t)↔existsAt(c2,t)∧continuantPartOf(c1,c2,t)))→occursIn(p,c2))

If something is located in something else then the region of the first is part of the region of the second [uas-1]
∀a,b,t(locatedIn(a,b,t)→∃r1,r2,t2(temporalPartOf(t2,t)∧occupiesSpatialRegion(a,r1,t2)∧occupiesSpatialRegion(b,r2,t2)∧continuantPartOf(r1,r2,t2)))

Occurs in has domain process or process boundary and range material entity or site [tfw-1]
∀a,b(occursIn(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧(∃t(instanceOf(b,materialEntity,t)∨instanceOf(b,site,t))))

Spatial regions don’t change what they are part of. [mlb-1]
∀s,sp (∃t(instanceOf(s,spatialRegion,t)∧continuantPartOf(sp,s,t))→∀t(∃sPrime continuantPartOf(sPrime,s,t) →continuantPartOf(sp,s,t)))

Occupies spatial region is time indexed and has domain: independent continuant but not spatial region and range: spatial region [lzw-1]
∀a,b,t(occupiesSpatialRegion(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

If there are two independent continuants that are not spatial regions, and one is part of the other, then it is located in the other [bao-1]
∀a,b,t(continuantPartOf(a,b,t)∧instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)→locatedIn(a,b,t))

Spatial region is the union of zero dimensional spatial region, one dimensional spatial region, two dimensional spatial region, and three dimensional spatial region [wnm-1]
∀i,t(instanceOf(i,spatialRegion,t)→instanceOf(i,zeroDimensionalSpatialRegion,t)∨instanceOf(i,oneDimensionalSpatialRegion,t)∨instanceOf(i,twoDimensionalSpatialRegion,t)∨instanceOf(i,threeDimensionalSpatialRegion,t))

No two material entities occupy the same space unless they coincide [scr-1]
∀m1,m2,s,t(instanceOf(m1,materialEntity,t)∧occupiesSpatialRegion(m1,s,t)∧instanceOf(m2,materialEntity,t)∧occupiesSpatialRegion(m2,s,t)→(continuantPartOf(m2,m1,t)∧continuantPartOf(m1,m2,t))∨m1=m2)

Located in is time indexed and has domain: independent continuant but not spatial region and range: independent continuant but not spatial region [bge-1]
∀a,b,t(locatedIn(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

At all times t, there’s a part of t when c occupies spatial region r iff every part of c occupies a part of r, and there isn’t a smaller part of r that c occupies. [grv-1]
∀c,r,t(instanceOf(c,independentContinuant,t)∧¬instanceOf(c,spatialRegion,t)∧instanceOf(r,spatialRegion,t)→∃t2(temporalPartOf(t2,t)∧(occupiesSpatialRegion(c,r,t2)↔(∀cp(continuantPartOf(cp,c,t2)→∀rp(occupiesSpatialRegion(cp,rp,t2)→continuantPartOf(rp,r,t2))))∧¬(∃r′(r′̸=r∧continuantPartOf(r′,r,t2)∧occupiesSpatialRegion(c,r′,t2))))))

___

**BFO 2020 Spatiotemporal Axioms**

If something occupies a temporal region, then it exists at that region [bmc-1]
∀a,t(occupiesTemporalRegion(a,t) →existsAt(a,t))

Exists at is a lower bound on first argument [jqz-1]
∀p,q,r(existsAt(p,q)∧temporalPartOf(p,r) →existsAt(r,q))

Occupies temporal region is functional on second argument [wzd-1]
∀p,q,r(occupiesTemporalRegion(p,q)∧occupiesTemporalRegion(p,r) →q=r)

Temporally projects onto is functional on second argument [jtq-1]
∀p,q,r(temporallyProjectsOnto(p,q)∧temporallyProjectsOnto(p,r) →q=r)

Spatially projects onto is functional on second argument [fdb-1]
∀p,q,r,s(spatiallyProjectsOnto(p,q,r)∧spatiallyProjectsOnto(p,s,r) →q=s)

Occupies spatiotemporal region is functional on second argument [uqt-1]
∀p,q,r(occupiesSpatiotemporalRegion(p,q)∧occupiesSpatiotemporalRegion(p,r) →q=r)

Occurs in is a lower bound on second argument [yex-1]
∀p,c1,c2(occursIn(p,c1)∧(∀t(existsAt(p,t) ↔locatedIn(c1,c2,t))) →occursIn(p,c2))

If a occupies spatial region b then if a is an instance of site then b is an instance of three dimensional spatial region [uqb-1]
∀p,q,t (occupiesSpatialRegion(p,q,t)∧instanceOf(p,site,t)
→instanceOf(q,threeDimensionalSpatialRegion,t))

The temporal region during which a process occurs is the same as that which the spatiotemporal region the process occupies temporally projects onto [cur-1]
∀p,t(occupiesTemporalRegion(p,t)↔∃st(occupiesSpatiotemporalRegion(p,st)∧temporallyProjectsOnto(st,t)))

A process boundary occupies a spatiotemporal instant [atz-1]
∀pb,tr(∃tinstanceOf(pb,processBoundary,t)∧occupiesTemporalRegion(pb,tr)→instanceOf(tr,temporalInstant,tr))

For every process there’s a corresponding spatiotemporal region [qyy-1]
∀p(∃t(instanceOf(p,process,t)∨instanceOf(p,processBoundary,t))→∃s occupiesSpatiotemporalRegion(p,s))

Temporally projects onto has domain spatiotemporal region and range temporal region [cvr-1]
∀a,b (temporallyProjectsOnto(a,b)→∃t instanceOf(a,spatiotemporalRegion,t)∧∃t instanceOf(b,temporalRegion,t))

Spatiotemporal regions always project on to some temporal region [scq-1]
∀st(∃tinstanceOf(st,spatiotemporalRegion,t)→∃t(instanceOf(t,temporalRegion,t)∧temporallyProjectsOnto(st,t)))

Spatially projects onto is time indexed and has domain: spatiotemporal region and range: spatial region [blj-1]
∀a,b,t(spatiallyProjectsOnto(a,b,t)→instanceOf(a,spatiotemporalRegion,t)∧instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

Every temporal region is a projection from a spatiotemporal region [xco-1]
∀tr(∃tinstanceOf(tr,temporalRegion,t)→∃st(∃tinstanceOf(st,spatiotemporalRegion,t)∧temporallyProjectsOnto(st,tr)))

Spatiotemporal regions always project on to some spatial region at any time [geq-1]
∀st,t(instanceOf(st,spatiotemporalRegion,t)→∃s,tp(temporalPartOf(tp,t)∧instanceOf(s,spatialRegion,tp)∧spatiallyProjectsOnto(st,s,tp)))


Occupies temporal region has domain process or process boundary and range temporal region [lyx-1]
∀a,b(occupiesTemporalRegion(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧∃t instanceOf(b,temporalRegion,t))

Every spatial region is a projection from a spatiotemporal region [mdb-1]
∀sr (∃t instanceOf(sr,spatialRegion,t)→∃st(∃t instanceOf(st,spatiotemporalRegion,t)∧∃t spatiallyProjectsOnto(st,sr,t)))

Occupies spatiotemporal region has domain process or process boundary and range spatiotemporal region [vvo-1]
∀a,b(occupiesSpatiotemporalRegion(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧∃t instanceOf(b,spatiotemporalRegion,t))

A process occupies at least a temporal interval [fzy-1]
∀proc,tr(∃tinstanceOf(proc,process,t)∧occupiesTemporalRegion(proc,tr)→∃interval(instanceOf(interval,temporalInterval,interval)∧temporalPartOf(interval,tr)))

If one occurrent is part of another, then the temporal region of the first is part of the temporal region of the second [jiv-1]
∀o1,o2,t1,t2((∃t(instanceOf(o1,process,t)∨instanceOf(o1,processBoundary,t)))∧∃t instanceOf(o2,process,t)∧occurrentPartOf(o1,o2)∧occupiesTemporalRegion(o1,t1)∧occupiesTemporalRegion(o2,t2)→temporalPartOf(t1,t2))

If one process or process boundary is part of another, then their corresponding temporal regions are also in a parthood relation [iqe-1]
∀o1,o2,st1,st2((∃t(instanceOf(o1,process,t)∨instanceOf(o1,processBoundary,t)))∧(∃t(instanceOf(o2,process,t)∨instanceOf(o2,processBoundary,t)))∧occurrentPartOf(o1,o2)∧occupiesSpatiotemporalRegion(o1,st1)∧occupiesSpatiotemporalRegion(o2,st2)→occurrentPartOf(st1,st2))

If a process or process boundary is part of another, their spatiotemporal regions are part too [kqv-1]
∀p1,p2((∃tinstanceOf(p1,process,t)∨∃tinstanceOf(p1,processBoundary,t))∧(∃tinstanceOf(p2,process,t)∨∃tinstanceOf(p2,processBoundary,t))→(occurrentPartOf(p1,p2)↔∃st1,st2(occupiesSpatiotemporalRegion(p1,st1)∧occupiesSpatiotemporalRegion(p2,st2)∧occurrentPartOf(st1,st2))))

Process or process boundary p occupies temporal region t iff every part of p temporally occupies a part of t, and there isn’t asmaller part of t that p occupies. [tao-1]
∀o,t((∃t1instanceOf(o,process,t1)∨∃t1instanceOf(o,processBoundary,t1))∧instanceOf(t,temporalRegion,t)→(occupiesTemporalRegion(o,t)↔(∀op(occurrentPartOf(op,o)→∀tp(occupiesTemporalRegion(op,tp)→occurrentPartOf(tp,t))))∧¬(∃t′(t′̸=t∧occurrentPartOf(t′,t)∧occupiesTemporalRegion(o,t′)))))

Process p (or boundary) occupies spatiotemporal region st iff every part of p occupies spatiotemporal region a part of st, and there isn’t a smaller part of st that p occupies. [dki-1]
∀o,st((∃t1instanceOf(o,process,t1)∨∃t1instanceOf(o,processBoundary,t1))∧∃t1instanceOf(st,spatiotemporalRegion,t1)→(occupiesSpatiotemporalRegion(o,st)↔(∀op(occurrentPartOf(op,o)→∀stp(occupiesSpatiotemporalRegion(op,stp)→occurrentPartOf(stp,st))))∧¬(∃st′(st′̸=st∧occurrentPartOf(st′,st)∧occupiesSpatiotemporalRegion(o,st′)))))

___

**BFO 2020 Specific Dependency Axioms**

Inheres in and bearer of are inverse relations [dzz-1]
∀a,b(inheresIn(a,b) ↔bearerOf(b,a))

Realizes and has realization are inverse relations [pvk-1]
∀a,b(realizes(a,b) ↔hasRealization(b,a))

Has material basis and material basis of are inverse relations [tla-1]
∀t,a,b(hasMaterialBasis(a,b,t) ↔materialBasisOf(b,a,t))

Specifically depends on and specifically depended on by are inverse relations [yct-1]
∀a,b(specificallyDependsOn(a,b) ↔specificallyDependedOnBy(b,a))

When a role is realized the bearer of the role participates in the realization process [grx-1]
∀r,p,b(realizes(p,r)∧inheresIn(r,b) →∃t participatesIn(b,p,t))

Has material basis is dissective on third argument, a temporal region [hnl-1]
∀p,q,r,s(hasMaterialBasis(p,q,r)∧temporalPartOf(s,r) →hasMaterialBasis(p,q,s))

Realizes has domain process and range realizable entity [oot-1]
∀a,b(realizes(a,b) →∃t instanceOf(a,process,t)∧∃t instanceOf(b,realizableEntity,t))

Specifically depends on is transitive [myu-1]
∀a,b,c(specificallyDependsOn(a,b)∧specificallyDependsOn(b,c)∧a̸=c→specificallyDependsOn(a,c))

If s s depends on c then s and c never share common parts (s,c continuants) [nfe-1]
∀s,c(specificallyDependsOn(s,c)→¬(∃w,t(continuantPartOf(w,s,t)∧continuantPartOf(w,c,t))))

A realizable entity exists at least at the beginning of the realization process [vhg-1]
∀r,p(realizes(p,r)→∃proct,first(occupiesTemporalRegion(p,proct)∧hasFirstInstant(proct,first)∧existsAt(r,first)))

Has material basis is time indexed and has domain: disposition and range: material entity [cfs-1]
∀a,b,t(hasMaterialBasis(a,b,t)→instanceOf(a,disposition,t)∧instanceOf(b,materialEntity,t)∧instanceOf(t,temporalRegion,t))

If x s depends on y then there’s at least one time when they both exist [iyu-1]
∀s,c(specificallyDependsOn(s,c)→(∃t(existsAt(s,t)∧existsAt(c,t)))∧(∀t(existsAt(s,t) →existsAt(c,t))))

DEFINITION: b is a relational quality = Def. b is a quality and there exists distinct c and d such that at all times t, b inheres in c if and only b specifically depends on. [dbp-1]
∀b(∃tinstanceOf(b,relationalQuality,t)↔(∃c,d(c̸=d∧inheresIn(b,c)∧specificallyDependsOn(b,d)))∧∃t instanceOf(b,quality,t))

Inheres in has domain specifically dependent continuant and range independent continuant but not spatial region [lmq-1]
∀a,b(inheresIn(a,b)→∃tinstanceOf(a,specificallyDependentContinuant,t)∧(∃t(instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t))))

A inheres in b =Def. a is a specifically dependent continuant and b is an independent continuant that is not a spatial region and a s depends on b. [tht-1]
∀a,b(inheresIn(a,b)↔specificallyDependsOn(a,b)∧(∃t(instanceOf(a,specificallyDependentContinuant,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t))))

Definition of specifically dependent continuant. [akq-1]
∀s(∃tinstanceOf(s,specificallyDependentContinuant,t)↔∃c,t(instanceOf(s,continuant,t)∧instanceOf(c,independentContinuant,t)∧¬instanceOf(c,spatialRegion,t)∧specificallyDependsOn(s,c)))

The material basis of a disposition is part of the bearer of the disposition [uxo-1]
∀m,d,b (∃t instanceOf(m,materialEntity,t)∧∃t instanceOf(d,disposition,t)∧∃t instanceOf(b,materialEntity,t)∧inheresIn(d,b)→∀t(hasMaterialBasis(d,m,t)→continuantPartOf(m,b,t)))

Specifically depends on has domain specifically dependent continuant and range specifically dependent continuant or independent continuant but not spatial region [kkl-1]
∀a,b(specificallyDependsOn(a,b)→∃tinstanceOf(a,specificallyDependentContinuant,t)∧(∃t(instanceOf(b,specificallyDependentContinuant,t)∨(instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)))))

At every time a specific dependent s participates in a process p there’s a part of that time, during which there’s an independent continuant that s s depends on, and that participates in p at that time [cgn-1]
∀sdc,p,t(instanceOf(sdc,specificallyDependentContinuant,t)∧participatesIn(sdc,p,t)→∃tp,ic(instanceOf(tp,temporalRegion,tp)∧temporalPartOf(tp,t)∧instanceOf(ic,independentContinuant,tp)∧¬instanceOf(ic,spatialRegion,tp)∧specificallyDependsOn(sdc,ic)∧participatesIn(ic,p,tp)))

__

**BFO 2020 At T Temporalized Axioms**

Located in at some time [asd-1]
∀p,q(locatedInAtSomeTime(p,q) ↔∃t(existsAt(p,t)∧existsAt(q,t)∧locatedIn(p,q,t)))

Concretizes at some time [gkc-1]
∀p,q (concretizesAtSomeTime(p,q)
↔∃t(existsAt(p,t)∧existsAt(q,t)∧concretizes(p,q,t)))

Location of at some time [spm-1]
∀p,q(locationOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧locationOf(p,q,t)))

Is carrier of at some time [qkm-1]
∀p,q (isCarrierOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧isCarrierOf(p,q,t)))

Member part of at some time [kax-1]
∀p,q(memberPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧memberPartOf(p,q,t)))

Has member part at some time [smy-1]
∀p,q(hasMemberPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasMemberPart(p,q,t)))

Has participant at some time [ebs-1]
∀p,q(hasParticipantAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasParticipant(p,q,t)))

Participates in at some time [oia-1]
∀p,q(participatesInAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧participatesIn(p,q,t)))

Rdf:type is interpreted as meaning an instance is a given type whenever it exists, and that the instance exists at some point. [fyy-1]
∀c,i(rdfType(c,i) ↔(∀t(existsAt(i,t) →instanceOf(i,c,t)))∧∃t existsAt(i,t))

Is concretized by at some time [zgk-1]
∀p,q(isConcretizedByAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧isConcretizedBy(p,q,t)))

Material basis of at some time [exa-1]
∀p,q(materialBasisOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧materialBasisOf(p,q,t)))

Continuant part of at some time [lzq-1]
∀p,q(continuantPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧continuantPartOf(p,q,t)))

Has material basis at some time [fqc-1]
∀p,q(hasMaterialBasisAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasMaterialBasis(p,q,t)))

Has continuant part at some time [jvz-1]
∀p,q(hasContinuantPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasContinuantPart(p,q,t)))

Generically depends on at some time [vrq-1]
∀p,q(genericallyDependsOnAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧genericallyDependsOn(p,q,t)))

Occupies spatial region at some time [yci-1]
∀p,q(occupiesSpatialRegionAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧occupiesSpatialRegion(p,q,t)))

Spatially projects onto at some time [epa-1]
∀p,q(spatiallyProjectsOntoAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧spatiallyProjectsOnto(p,q,t)))

Proper continuant part of at some time [sql-1]
∀p,q(properContinuantPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧properContinuantPartOf(p,q,t)))

Has proper continuant part at some time [ule-1]
∀p,q(hasProperContinuantPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasProperContinuantPart(p,q,t)))

Located in at all times [vdo-1]
∀p,q(locatedInAtAllTimes(p,q)↔(∃t(locatedIn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→locatedIn(p,q,t))))

Concretizes at all times [uge-1]
∀p,q(concretizesAtAllTimes(p,q)↔(∃t(concretizes(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→concretizes(p,q,t))))

Location of at all times [imi-1]
∀p,q(locationOfAtAllTimes(p,q)↔(∃t(locationOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→locationOf(p,q,t))))

Is carrier of at all times [fya-1]
∀p,q(isCarrierOfAtAllTimes(p,q)↔(∃t(isCarrierOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→isCarrierOf(p,q,t))))

Member part of at all times [maf-1]
∀p,q(memberPartOfAtAllTimes(p,q)↔(∃t(memberPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →memberPartOf(p,q,t))))

Has member part at all times [xwi-1]
∀p,q(hasMemberPartAtAllTimes(p,q)↔(∃t(hasMemberPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasMemberPart(p,q,t))))

Has participant at all times [wyo-1]
∀p,q(hasParticipantAtAllTimes(p,q)↔(∃t(hasParticipant(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasParticipant(p,q,t))))

Participates in at all times [ghl-1]
∀p,q(participatesInAtAllTimes(p,q)↔(∃t(participatesIn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→participatesIn(p,q,t))))

Is concretized by at all times [qhq-1]
∀p,q(isConcretizedByAtAllTimes(p,q)↔(∃t(isConcretizedBy(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →isConcretizedBy(p,q,t))))

Material basis of at all times [scx-1]
∀p,q(materialBasisOfAtAllTimes(p,q)↔(∃t(materialBasisOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→materialBasisOf(p,q,t))))

Continuant part of at all times [ztt-1]
∀p,q(continuantPartOfAtAllTimes(p,q)↔(∃t(continuantPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →continuantPartOf(p,q,t))))

Has material basis at all times [qdl-1]
∀p,q(hasMaterialBasisAtAllTimes(p,q)↔(∃t(hasMaterialBasis(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasMaterialBasis(p,q,t))))

Has continuant part at all times [uhy-1]
∀p,q(hasContinuantPartAtAllTimes(p,q)↔(∃t(hasContinuantPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasContinuantPart(p,q,t))))

Generically depends on at all times [wie-1]
∀p,q(genericallyDependsOnAtAllTimes(p,q)↔(∃t(genericallyDependsOn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →genericallyDependsOn(p,q,t))))

Occupies spatial region at all times [tpr-1]
∀p,q(occupiesSpatialRegionAtAllTimes(p,q)↔(∃t(occupiesSpatialRegion(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →occupiesSpatialRegion(p,q,t))))

Spatially projects onto at all times [ogh-1]
∀p,q(spatiallyProjectsOntoAtAllTimes(p,q)↔(∃t(spatiallyProjectsOnto(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →spatiallyProjectsOnto(p,q,t))))

Proper continuant part of at all times [jiz-1]
∀p,q(properContinuantPartOfAtAllTimes(p,q)↔(∃t(properContinuantPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →properContinuantPartOf(p,q,t))))

Has proper continuant part at all times [mxe-1]
∀p,q(hasProperContinuantPartAtAllTimes(p,q)↔(∃t(hasProperContinuantPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasProperContinuantPart(p,q,t))))

___

**BFO 2020 Temporal Region Axioms**

Has last instant and last instant of are inverse relations [wal-1]
∀a,b(hasLastInstant(a,b)↔lastInstantOf(b,a))

Has first instant and first instant of are inverse relations [bon-1]
∀a,b(hasFirstInstant(a,b)↔firstInstantOf(b,a))

Temporal part of and has temporal part are inverse relations [boo-1]
∀a,b(temporalPartOf(a,b)↔hasTemporalPart(b,a))

Temporal part of for occurrents implies occurrent part of [bal-1]
∀a,b(temporalPartOf(a,b)→occurrentPartOf(a,b))

Proper temporal part of and has proper temporal part are inverse relations [dbc-1]
∀a,b(properTemporalPartOf(a,b)↔hasProperTemporalPart(b,a))

If something is an instance of temporal region at t, then t is part of that temporal region [njq-1]
∀ti,t(instanceOf(ti,temporalRegion,t)→temporalPartOf(t,ti))

Temporal part of is reflexive [bvr-1]
∀a(∃t instanceOf(a,occurrent,t)→temporalPartOf(a,a))

Temporal part of is antisymmetric [zdq-1]
∀a,b(temporalPartOf(a,b)∧temporalPartOf(b,a) →a=b)

Proper temporal part of is asymmetric [aqu-1]
∀a,b(properTemporalPartOf(a,b)→¬properTemporalPartOf(b,a))

Has last instant is functional on second argument [ogd-1]
∀p,q,r(hasLastInstant(p,q)∧hasLastInstant(p,r)→q=r)

Temporal part of is reflexive [dbj-1]
∀a(∃t instanceOf(a,temporalRegion,t)→temporalPartOf(a,a))

Has first instant is functional on second argument [fwf-1]
∀p,q,r(hasFirstInstant(p,q)∧hasFirstInstant(p,r)→q=r)

A proper temporal part of b means a is a temporal part of b and b a is not the same as b [aeu-1]
∀x,y(properTemporalPartOf(x,y) ↔temporalPartOf(x,y)∧x̸=y)

Instance of is dissective on third argument, a temporal region [qaf-1]
∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r) →instanceOf(p,q,s))

Temporal part of is transitive [bfq-1]
∀a,b,c(temporalPartOf(a,b)∧temporalPartOf(b,c) →temporalPartOf(a,c))

The first and last time points for an instant are the instant itself [nfo-1]
∀i(instanceOf(i,temporalInstant,i) ↔hasFirstInstant(i,i)∧hasLastInstant(i,i))

The only part of a temporal instant is itself [pir-1]
∀p,q(∃t instanceOf(p,temporalInstant,t)∧hasTemporalPart(p,q) →p=q)

Temporal regions are instances at themselves [tvx-1]
∀a,u(∃t(instanceOf(a,temporalRegion,t)∧instanceOf(a,u,t)) →instanceOf(a,u,a))

Proper temporal part of is transitive [mns-1]
∀a,b,c(properTemporalPartOf(a,b)∧properTemporalPartOf(b,c)→properTemporalPartOf(a,c))

If the last instant of a temporal region precedes the first instant of another, then the first region precedes the second [qqv-1]
∀i1,i2,l1,f2 (hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧precedes(l1,f2)→precedes(i1,i2))

Any temporal region has a first and last instant [daf-1]
∀i (instanceOf(i,temporalRegion,i)→∃t1,t2(hasFirstInstant(i,t1)∧hasLastInstant(i,t2)))

All temporal regions are part of a temporal interval [mvd-1]
∀t(instanceOf(t,temporalRegion,t)→∃i(instanceOf(i,temporalInterval,i)∧temporalPartOf(t,i)))

Temporal part of has domain occurrent and range occurrent [ruj-1]
∀a,b(temporalPartOf(a,b) →∃t instanceOf(a,occurrent,t)∧∃t instanceOf(b,occurrent,t))

First instant of a temporal region that is not an instant precedes last instant [rzv-1]
∀t,ft,lt(¬instanceOf(t,temporalInstant,t)∧hasFirstInstant(t,ft)∧hasLastInstant(t,lt)→precedes(ft,lt))

If one temporal region precedes another then the first last time point precedes the second first time point [miz-1]
∀t1,t2,l1,f2(precedes(t1,t2)∧hasLastInstant(t1,l1)∧hasFirstInstant(t2,f2)∧l1̸=f2→precedes(l1,f2))

If a temporal part of b then if a is an instance of temporal region then b is an instance of temporal region, and vice versa[mjn-1]
∀p,q (temporalPartOf(p,q)→(∃t instanceOf(p,temporalRegion,t) ↔∃tinstanceOf(q,temporalRegion,t)))

Has last instant has domain temporal region and range temporal instant [jtk-1]
∀a,b(hasLastInstant(a,b)→∃tinstanceOf(a,temporalRegion,t)∧∃tinstanceOf(b,temporalInstant,t))

Has first instant has domain temporal region and range temporal instant [fwk-1]
∀a,b(hasFirstInstant(a,b)→∃tinstanceOf(a,temporalRegion,t)∧∃tinstanceOf(b,temporalInstant,t))

A one dimensional temporal region has at least one interval as part [jhe-1]
∀t(instanceOf(t,oneDimensionalTemporalRegion,t)→∃p(temporalPartOf(p,t)∧instanceOf(p,temporalInterval,p)))

Temporal instants are totally ordered [qnf-1]
∀t1,t2(instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)→precedes(t1,t2)∨precedes(t2,t1)∨t1=t2)

Temporal region is the union of zero dimensional temporal region and one dimensional temporal region [hgs-1]
∀i,t(instanceOf(i,temporalRegion,t)→instanceOf(i,zeroDimensionalTemporalRegion,t)∨instanceOf(i,oneDimensionalTemporalRegion,t))

If a temporal part of b then if a is an instance of one dimensional temporal region then b is an instance of one dimensionaltemporal region [mei-1]
∀p,q(temporalPartOf(p,q)→(∃tinstanceOf(p,oneDimensionalTemporalRegion,t)→∃t instanceOf(q,oneDimensionalTemporalRegion,t)))

If a has temporal part b then if a is an instance of zero dimensional temporal region then b is an instance of zero dimensional temporal region [bnt-1]
∀p,q(hasTemporalPart(p,q)→(∃tinstanceOf(p,zeroDimensionalTemporalRegion,t)→∃t instanceOf(q,zeroDimensionalTemporalRegion,t)))

If the last instant of a temporal region is the first instant of another, the first region precedes the second [suk-1]
∀i1,i2,l1,f2(¬instanceOf(i1,temporalInstant,i1)∧¬instanceOf(i2,temporalInstant,i2)∧hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧l1=f2→precedes(i1,i2))

A last instant is either part of an extended region or is preceded by it [acg-1]
∀l,i(instanceOf(l,temporalInstant,l)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasLastInstant(i,l)→(¬temporalPartOf(l,i) ↔precedes(i,l)))

A first instant is either part of an extended region or precedes it [qga-1]
∀f,i(instanceOf(f,temporalInstant,f)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasFirstInstant(i,f)→(¬temporalPartOf(f,i) ↔precedes(f,i)))

If two temporal intervals do not overlap then one of them precedes the other [owb-1]
∀t1,t2(instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(t1,t2)∨precedes(t2,t1))

If a has temporal part b then if a is an instance of one dimensional temporal region then b is an instance of one dimensional temporal region or zero dimensional temporal region [eeg-1]
∀p,q(hasTemporalPart(p,q)→(∃tinstanceOf(p,oneDimensionalTemporalRegion,t)→∃t(instanceOf(q,oneDimensionalTemporalRegion,t)∨instanceOf(q,zeroDimensionalTemporalRegion,t))))

The first temporal instant is such that it precedes every part of the interval that doesn’t have the first instant as part [ixz-1]
∀fi,i(instanceOf(fi,temporalInstant,fi)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)→(hasFirstInstant(i,fi)→∀ip(temporalPartOf(ip,i)∧¬temporalPartOf(fi,ip)→precedes(fi,ip))))

The last temporal instant is such that every part of the interval that doesn’t have the last instant as part precedes it [nhd-1]
∀li,i(instanceOf(li,temporalInstant,li)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)→(hasLastInstant(i,li)→(∀ip(temporalPartOf(ip,i)∧¬temporalPartOf(li,ip)→precedes(ip,li)))))

Intervals have no internal gaps [ekm-1]
∀i,start,end(instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→¬(∃gap,gapStart,gapEnd(hasFirstInstant(gap,gapStart)∧hasLastInstant(gap,gapEnd)∧precedes(gapEnd,end)∧precedes(start,gapStart)∧¬temporalPartOf(gap,i))))

Temporal part of has weak supplementation [vbw-1]
∀x,y(instanceOf(x,temporalRegion,x)∧instanceOf(y,temporalRegion,y)→(properTemporalPartOf(x,y)→∃z(properTemporalPartOf(z,y)∧¬(∃overlap(instanceOf(overlap,temporalRegion,overlap)∧temporalPartOf(overlap,x)∧temporalPartOf(overlap,z))))))

Any temporal instant that precedes the last instant of an interval and which is preceded by the first instant is part of theinterval [zlp-1]
∀t,r(instanceOf(t,temporalInstant,t)∧instanceOf(r,temporalInterval,r)→hasFirstInstant(r,t)∨hasLastInstant(r,t)∨(∃f,l(instanceOf(r,temporalInterval,r)∧hasFirstInstant(r,f)∧hasLastInstant(r,l)∧precedes(t,l)∧precedes(f,t))↔properTemporalPartOf(t,r)))

Two intervals are identical if their first and last instants are the same and if an instant is part of one of the intervals it is also part of the other [xkl-1]
∀i1,i2(instanceOf(i1,temporalInterval,i1)∧instanceOf(i2,temporalInterval,i2)→(∃f,l(hasFirstInstant(i1,f)∧hasFirstInstant(i2,f)∧hasLastInstant(i1,l)∧hasLastInstant(i2,l)∧(temporalPartOf(l,i1)↔temporalPartOf(l,i2))∧(temporalPartOf(f,i1)↔temporalPartOf(f,i2)))→i1=i2))

Temporal part of has unique product [wsg-1]
∀x,y(instanceOf(x,temporalRegion,x)∧instanceOf(y,temporalRegion,y)→(∃o(temporalPartOf(o,x)∧temporalPartOf(o,y))→∃z(instanceOf(z,temporalRegion,z)∧(∀w(instanceOf(w,temporalRegion,w)∧instanceOf(z,temporalRegion,z)→(temporalPartOf(w,z)↔temporalPartOf(w,x)∧temporalPartOf(w,y)))))))

An interval has no gaps [nui-1]
∀i,start,end(instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→¬(∃gap,gapStart,gapEnd(¬instanceOf(gap,temporalInstant,gap)∧hasFirstInstant(gap,gapStart)∧hasLastInstant(gap,gapEnd)∧(precedes(gapEnd,end)∨(temporalPartOf(end,i)∧gapEnd=end))∧(precedes(start,gapStart)∨(temporalPartOf(start,i)∧gapStart=start))
∧¬temporalPartOf(gap,i))))

Intervals have no gaps strong version every two instants without another in between bound an interval [cop-1]
∀i,start,end (instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→∀t1,t2(temporalPartOf(t1,i)∧temporalPartOf(t2,i)∧instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)∧precedes(t1,t2)∧¬(∃t3(instanceOf(t3,temporalInstant,t3)∧precedes(t1,t3)∧precedes(t3,t2)))→∃fill(instanceOf(fill,temporalInterval,fill)∧hasFirstInstant(fill,t1)∧hasLastInstant(fill,t2)∧temporalPartOf(fill,i))))

___

**BFO 2020 Universal Declaration Axioms**

Role is a universal [ewm-1]
universal(role)

Site is a universal [yhb-1]
universal(site)

Object is a universal [kxo-1]
universal(object)

History is a universal [gki-1]
universal(history)

Process is a universal [bsm-1]
universal(process)

Quality is a universal [mit-1]
universal(quality)

Function is a universal [rym-1]
universal(function)

Fiat line is a universal [spk-1]
universal(fiatLine)

Occurrent is a universal [lkt-1]
universal(occurrent)

Continuant is a universal [axs-1]
universal(continuant)

Fiat point is a universal [rns-1]
universal(fiatPoint)

Disposition is a universal [mld-1]
universal(disposition)

Fiat surface is a universal [ebw-1]
universal(fiatSurface)

Spatial region is a universal [qga-1]
universal(spatialRegion)

Material entity is a universal [hru-1]
universal(materialEntity)

Temporal region is a universal [toj-1]
universal(temporalRegion)

Fiat object part is a universal [csp-1]
universal(fiatObjectPart)

Object aggregate is a universal [cqv-1]
universal(objectAggregate)

Process boundary is a universal [zqv-1]
universal(processBoundary)

Temporal instant is a universal [bjs-1]
universal(temporalInstant)

Immaterial entity is a universal [zcc-1]
universal(immaterialEntity)

Realizable entity is a universal [gpp-1]
universal(realizableEntity)

Temporal interval is a universal [kuz-1]
universal(temporalInterval)

Relational quality is a universal [zrp-1]
universal(relationalQuality)

Spatiotemporal region is a universal [mdh-1]
universal(spatiotemporalRegion)

Independent continuant is a universal [ufw-1]
universal(independentContinuant)

Continuant fiat boundary is a universal [zvi-1]
universal(continuantFiatBoundary)

One dimensional spatial region is a universal [zwl-1]
universal(oneDimensionalSpatialRegion)

Two dimensional spatial region is a universal [whi-1]
universal(twoDimensionalSpatialRegion)

One dimensional temporal region is a universal [qar-1]
universal(oneDimensionalTemporalRegion)

Zero dimensional spatial region is a universal [vij-1]
universal(zeroDimensionalSpatialRegion)

Universals and particulars comprise the whole domain of discourse [eto-1]
∀x(universal(x)∨particular(x))

Generically dependent continuant is a universal [qiz-1]
universal(genericallyDependentContinuant)

Three dimensional spatial region is a universal [qov-1]
universal(threeDimensionalSpatialRegion)

Zero dimensional temporal region is a universal [bau-1]
universal(zeroDimensionalTemporalRegion)

Specifically dependent continuant is a universal [wda-1]
universal(specificallyDependentContinuant)

Universals are not particulars [qkp-1]
¬(∃x(universal(x)∧particular(x)))

History is subclass of process [abo-1]
∀t,x(instanceOf(x,history,t)→instanceOf(x,process,t))

Process is subclass of occurrent [lso-1]
∀t,x(instanceOf(x,process,t)→instanceOf(x,occurrent,t))

Function is subclass of disposition [lnj-1]
∀t,x(instanceOf(x,function,t)→instanceOf(x,disposition,t))

Object is subclass of material entity [vbm-1]
∀t,x(instanceOf(x,object,t)→instanceOf(x,materialEntity,t))

Role is subclass of realizable entity [tcp-1]
∀t,x(instanceOf(x,role,t)→instanceOf(x,realizableEntity,t))

Site is subclass of immaterial entity [tcd-1]
∀t,x(instanceOf(x,site,t)→instanceOf(x,immaterialEntity,t))

If something is an instance of temporal region at t, then t is part of that temporal region [njq-1]
∀ti,t(instanceOf(ti,temporalRegion,t)→temporalPartOf(t,ti))

Temporal region is subclass of occurrent [ejl-1]
∀t,x(instanceOf(x,temporalRegion,t)→instanceOf(x,occurrent,t))

Disposition, role are mutually disjoint [bwk-1]
¬(∃x,t(instanceOf(x,disposition,t)∧instanceOf(x,role,t)))

Process boundary is subclass of occurrent [xot-1]
∀t,x(instanceOf(x,processBoundary,t)→instanceOf(x,occurrent,t))

Relational quality is subclass of quality [taj-1]
∀t,x(instanceOf(x,relationalQuality,t)→instanceOf(x,quality,t))

Disposition is subclass of realizable entity [fxd-1]
∀t,x(instanceOf(x,disposition,t)→instanceOf(x,realizableEntity,t))

Continuant, occurrent are mutually disjoint [wrf-1]
¬(∃x,t(instanceOf(x,continuant,t)∧instanceOf(x,occurrent,t)))

Spatiotemporal region is subclass of occurrent [les-1]
∀t,x(instanceOf(x,spatiotemporalRegion,t)→instanceOf(x,occurrent,t))

Fiat object part is subclass of material entity [lal-1]
∀t,x(instanceOf(x,fiatObjectPart,t)→instanceOf(x,materialEntity,t))

Object aggregate is subclass of material entity [fda-1]
∀t,x(instanceOf(x,objectAggregate,t)→instanceOf(x,materialEntity,t))

Spatial region is subclass of immaterial entity [bre-1]
∀t,x(instanceOf(x,spatialRegion,t)→instanceOf(x,immaterialEntity,t))

Independent continuant is subclass of continuant [wyq-1]
∀t,x(instanceOf(x,independentContinuant,t)→instanceOf(x,continuant,t))

Fiat line is subclass of continuant fiat boundary [dhy-1]
∀t,x(instanceOf(x,fiatLine,t)→instanceOf(x,continuantFiatBoundary,t))

Quality, realizable entity are mutually disjoint [ksk-1]
¬(∃x,t(instanceOf(x,quality,t)∧instanceOf(x,realizableEntity,t)))

Fiat point is subclass of continuant fiat boundary [xlm-1]
∀t,x(instanceOf(x,fiatPoint,t)→instanceOf(x,continuantFiatBoundary,t))

Fiat surface is subclass of continuant fiat boundary [kfj-1]
∀t,x(instanceOf(x,fiatSurface,t)→instanceOf(x,continuantFiatBoundary,t))

Material entity is subclass of independent continuant [faf-1]
∀t,x(instanceOf(x,materialEntity,t)→instanceOf(x,independentContinuant,t))

Immaterial entity is subclass of independent continuant [bzp-1]
∀t,x(instanceOf(x,immaterialEntity,t)→instanceOf(x,independentContinuant,t))

Quality is subclass of specifically dependent continuant [nbm-1]
∀t,x(instanceOf(x,quality,t)→instanceOf(x,specificallyDependentContinuant,t))

Continuant fiat boundary is subclass of immaterial entity [tgs-1]
∀t,x(instanceOf(x,continuantFiatBoundary,t)→instanceOf(x,immaterialEntity,t))

Material entity, immaterial entity are mutually disjoint [sij-1]
¬(∃x,t(instanceOf(x,materialEntity,t)∧instanceOf(x,immaterialEntity,t)))

Generically dependent continuant is subclass of continuant [zyw-1]
∀t,x(instanceOf(x,genericallyDependentContinuant,t)→instanceOf(x,continuant,t)) 

Specifically dependent continuant is subclass of continuant [dhv-1]
∀t,x(instanceOf(x,specificallyDependentContinuant,t)→instanceOf(x,continuant,t))

One dimensional spatial region is subclass of spatial region [fzn-1]
∀t,x(instanceOf(x,oneDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Two dimensional spatial region is subclass of spatial region [abo-1]
∀t,x(instanceOf(x,twoDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Zero dimensional spatial region is subclass of spatial region [abh-1]
∀t,x(instanceOf(x,zeroDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

One dimensional temporal region is subclass of temporal region [fpd-1]
∀t,x(instanceOf(x,oneDimensionalTemporalRegion,t)→instanceOf(x,temporalRegion,t))

Three dimensional spatial region is subclass of spatial region [apt-1]
∀t,x(instanceOf(x,threeDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Zero dimensional temporal region is subclass of temporal region [pvu-1]
∀t,x(instanceOf(x,zeroDimensionalTemporalRegion,t)→instanceOf(x,temporalRegion,t))

Temporal instant is subclass of zero dimensional temporal region [bjp-1]
∀t,x(instanceOf(x,temporalInstant,t)→instanceOf(x,zeroDimensionalTemporalRegion,t))

Temporal interval is subclass of one dimensional temporal region [fye-1]
∀t,x(instanceOf(x,temporalInterval,t)→instanceOf(x,oneDimensionalTemporalRegion,t))

Entity is either universal or particular, so not all are instantiated. Instead make a predicate ’entity’ analogous to particular universal [vgn-1]
∀x(∃t(instanceOf(x,continuant,t)∨instanceOf(x,occurrent,t))→entity(x))

Realizable entity is subclass of specifically dependent continuant [qix-1]
∀t,x(instanceOf(x,realizableEntity,t)→instanceOf(x,specificallyDependentContinuant,t))

If something is a role at any time then as long as it exists it is a role. [hxo-1]
∀x(∃tinstanceOf(x,role,t)→∀t(existsAt(x,t)→instanceOf(x,role,t)))

If something is a site at any time then as long as it exists it is a site. [txn-1]
∀x(∃tinstanceOf(x,site,t)→∀t(existsAt(x,t)→instanceOf(x,site,t)))

If something is a quality at any time then as long as it exists it is a quality. [jdo-1]
∀x(∃tinstanceOf(x,quality,t)→∀t(existsAt(x,t)→instanceOf(x,quality,t)))

If something is a function at any time then as long as it exists it is a function. [hww-1]
∀x(∃tinstanceOf(x,function,t)→∀t(existsAt(x,t)→instanceOf(x,function,t)))

One dimensional temporal region, zero dimensional temporal region are mutually disjoint [zkj-1]
¬(∃x,t(instanceOf(x,oneDimensionalTemporalRegion,t)∧instanceOf(x,zeroDimensionalTemporalRegion,t)))

If something is a fiat line at any time then as long as it exists it is a fiat line. [ylr-1]
∀x(∃tinstanceOf(x,fiatLine,t)→∀t(existsAt(x,t)→instanceOf(x,fiatLine,t)))

If something is a continuant at any time then as long as it exists it is a continuant. [ghs-1]
∀x(∃tinstanceOf(x,continuant,t)→∀t(existsAt(x,t)→instanceOf(x,continuant,t)))

If something is a fiat point at any time then as long as it exists it is a fiat point. [cqf-1]
∀x(∃tinstanceOf(x,fiatPoint,t)→∀t(existsAt(x,t)→instanceOf(x,fiatPoint,t)))

If something is a disposition at any time then as long as it exists it is a disposition. [ijx-1]
∀x(∃tinstanceOf(x,disposition,t)→∀t(existsAt(x,t)→instanceOf(x,disposition,t)))

If something is a fiat surface at any time then as long as it exists it is a fiat surface. [dyv-1]
∀x(∃tinstanceOf(x,fiatSurface,t)→∀t(existsAt(x,t)→instanceOf(x,fiatSurface,t)))

If something is a spatial region at any time then as long as it exists it is a spatial region. [thk-1]
∀x(∃tinstanceOf(x,spatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,spatialRegion,t)))

If something is a material entity at any time then as long as it exists it is a material entity. [opd-1]
∀x(∃tinstanceOf(x,materialEntity,t)→∀t(existsAt(x,t)→instanceOf(x,materialEntity,t)))

If something is a immaterial entity at any time then as long as it exists it is a immaterial entity. [nlc-1]
∀x(∃tinstanceOf(x,immaterialEntity,t)→∀t(existsAt(x,t)→instanceOf(x,immaterialEntity,t)))

If something is a realizable entity at any time then as long as it exists it is a realizable entity. [gsg-1]
∀x(∃tinstanceOf(x,realizableEntity,t)→∀t(existsAt(x,t)→instanceOf(x,realizableEntity,t)))

If something is a relational quality at any time then as long as it exists it is a relational quality. [jyh-1]
∀x(∃tinstanceOf(x,relationalQuality,t)→∀t(existsAt(x,t)→instanceOf(x,relationalQuality,t)))

If something is a independent continuant at any time then as long as it exists it is a independent continuant. [otk-1]
∀x(∃tinstanceOf(x,independentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,independentContinuant,t)))

If something is a continuant fiat boundary at any time then as long as it exists it is a continuant fiat boundary. [yuh-1]
∀x(∃tinstanceOf(x,continuantFiatBoundary,t)→∀t(existsAt(x,t)→instanceOf(x,continuantFiatBoundary,t)))

If something is a one dimensional spatial region at any time then as long as it exists it is a one dimensional spatial region. [bld-1]
∀x(∃tinstanceOf(x,oneDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,oneDimensionalSpatialRegion,t)))

If something is a two dimensional spatial region at any time then as long as it exists it is a two dimensional spatial region. [uld-1]
∀x(∃tinstanceOf(x,twoDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,twoDimensionalSpatialRegion,t)))

If something is a zero dimensional spatial region at any time then as long as it exists it is a zero dimensional spatial region. [vsa-1]
∀x(∃tinstanceOf(x,zeroDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,zeroDimensionalSpatialRegion,t)))

If something is a generically dependent continuant at any time then as long as it exists it is a generically dependent continuant. [iup-1]
∀x(∃tinstanceOf(x,genericallyDependentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,genericallyDependentContinuant,t)))

If something is a three dimensional spatial region at any time then as long as it exists it is a three dimensional spatial region. [qpr-1]
∀x(∃tinstanceOf(x,threeDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,threeDimensionalSpatialRegion,t)))

If something is a specifically dependent continuant at any time then as long as it exists it is a specifically dependent continuant. [hke-1]
∀x(∃tinstanceOf(x,specificallyDependentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,specificallyDependentContinuant,t)))

No occurrent changes type during its existence [ayr-1]
∀o(∃tinstanceOf(o,occurrent,t)→∀u(∃tinstanceOf(o,u,t)→∀t(instanceOf(o,occurrent,t)↔instanceOf(o,u,t))))

Fiat surface, fiat line, fiat point are mutually disjoint [sjf-1]
¬(∃x,t(instanceOf(x,fiatSurface,t)∧instanceOf(x,fiatLine,t)))
∧¬(∃x,t(instanceOf(x,fiatSurface,t)∧instanceOf(x,fiatPoint,t)))
∧¬(∃x,t(instanceOf(x,fiatLine,t)∧instanceOf(x,fiatPoint,t)))

Site, spatial region, continuant fiat boundary are mutually disjoint [twc-1]
¬(∃x,t(instanceOf(x,site,t)∧instanceOf(x,spatialRegion,t)))
∧¬(∃x,t(instanceOf(x,site,t)∧instanceOf(x,continuantFiatBoundary,t)))
∧¬(∃x,t(instanceOf(x,spatialRegion,t)∧instanceOf(x,continuantFiatBoundary,t)))

Specifically dependent continuant, independent continuant, generically dependent continuant are mutually disjoint [cig-1]
¬(∃x,t(instanceOf(x,specificallyDependentContinuant,t)
∧instanceOf(x,independentContinuant,t)))
∧¬(∃x,t(instanceOf(x,specificallyDependentContinuant,t)
∧instanceOf(x,genericallyDependentContinuant,t)))
∧¬(∃x,t(instanceOf(x,independentContinuant,t)
∧instanceOf(x,genericallyDependentContinuant,t)))

Process, spatiotemporal region, process boundary, temporal region are mutually disjoint [mem-1]
¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,spatiotemporalRegion,t)))
∧¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,processBoundary,t)))
∧¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,temporalRegion,t)))
∧¬(∃x,t(instanceOf(x,spatiotemporalRegion,t)∧instanceOf(x,processBoundary,t)))
∧¬(∃x,t(instanceOf(x,spatiotemporalRegion,t)∧instanceOf(x,temporalRegion,t)))
∧¬(∃x,t(instanceOf(x,processBoundary,t)∧instanceOf(x,temporalRegion,t)))

Continuant, material entity, object, fiat object part, object aggregate, site, immaterial entity, continuant fiat boundary, fiat surface, fiat line, fiat point, spatial region, three-dimensional spatial region, two dimensional spatial region, one dimensional spatial region, zero dimensional spatial region, independent continuant, generically dependent continuant, specifically dependent continuant, quality, relational quality, function, disposition, realizable entity, role, occurrent, process, process boundary, temporal region, zero dimensional temporal region, temporal instant, one dimensional temporal region, temporal interval, history, spatiotemporal region are all different [xtf-1]

The axiom is too large to show. It is a conjunction of 1190 pairwise inequalities between the constants continuant, materialEntity, object, fiatObjectPart, objectAggregate, site, immaterialEntity, continuantFiatBoundary, fiatSurface, fiatLine, fiatPoint, spatialRegion, threeDimensionalSpatialRegion, twoDimensionalSpatialRegion, oneDimensionalSpatialRegion, zeroDimensionalSpatialRegion, independentContinuant, genericallyDependentContinuant, specificallyDependentContinuant, quality,
relationalQuality, function, disposition, realizableEntity, role, occurrent, process, processBoundary, temporalRegion, zeroDimensionalTemporalRegion, temporalInstant, oneDimensionalTemporalRegion, temporalInterval, history and spatiotemporalRegion.

Zero dimensional spatial region, one dimensional spatial region, two dimensional spatial region, three dimensional spatial region are mutually disjoint [luc-1]

¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,oneDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,twoDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,oneDimensionalSpatialRegion,t)
∧instanceOf(x,twoDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,oneDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,twoDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))

___

**Part 2–Objective 3:**

3. Validate the SHACL schema/file for BFO by running the SHACL file against the knowledge graph based on BFO and generate a report absent errors or warnings

After creating 96 validated FOL enforced SHACL shapes, we added all of them into the **BFO FINAL SHACL Schema file**. 

**BFO FINAL SHACL Schema with 96 FOL Enforced Shapes:**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/4.%20Project_5_FINAL_BFO_SHACL_Schema.ttl

When we ran SHACL4Protege to validate our final schema, it returned an error. 

<img width="1533" alt="BFO FINAL SHACL Schema Result" src="https://user-images.githubusercontent.com/123851163/232389476-c665765d-a5b4-4965-8e2a-b51e5cc745cb.png">

In an attempt to try and return a result with no errors, we created a reduced SHACL schema called **BFO Special Collection SHACL Schema**. 

**BFO Special Collection SHACL Schema (Only Added Continuant Mereology, Existence Instantiation, and Generic Dependence):**
https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/Project-5/4.%20Project_5_FINAL_BFO_SHACL_Schema.ttl

In this file we only added the continuant mereology, existence instantiation, and generic dependence SHACL shapes. When we ran SHACL4Protege to validate our final schema, the result was more promising as it returned no errors. However, though the result returned no errors, it returned with 1197 violations.

![BFO Special Collection SHACL Schema Result](https://user-images.githubusercontent.com/123851163/232389066-eb3112e4-683d-44ee-9899-4ab1453b9577.png)

The scope of this project was enormous and we unforunately were not able to construct FOL enforced SHACL shapes for every axiom in BFO 2020. 

However, we did complete the majority of axioms from the following sections: Continuant Mereology, Existence Instantiation, Generic Dependence, History, Material Entity, Occurrent Mereology, and Order. We also completed 4 for Spatial Axioms. 

Moreover, although we were unable to achieve the intended objective of creating a summative final SHACL schema that returns no errors or violations, we were able to gain deep insight on BFO FOL axioms and SHACL syntax, engage in meaningful and challenging work representing FOL axioms through SHACL shapes, create novel FOL enforced SHACL shapes, and receive new knowledge about this project's aims and the requisites for its completion—hopefully to be transmitted to the next group of people tasked to work on this project.
